{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to 'Developing Bevy games using TDD'","text":"<p>Welcome to 'Developing Bevy games using TDD', The goal of this web-friendly book is to demonstrate how to do Test-Driven Development with Bevy.</p> <p></p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the   overall community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or   advances of any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email   address, without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at rjcbilderbeek@gmail.com. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.0, available at https://www.contributor-covenant.org/version/2/0/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing","text":"<p>Thanks for considering to contribute and reading this!</p> <p>Here we discuss how to contribute:</p> <ul> <li>spoken text, e.g. ideas, feedback, etc. and are written in English.</li> <li>book text, e.g. textual changes to the book</li> <li>code, e.g. changes to the Rust code</li> </ul>"},{"location":"CONTRIBUTING/#spoken-text","title":"Spoken text","text":"<p>Spoken text suggestions are ideas, feedback, etc. and are written in English.</p> <p>For ideas or feedback, create an Issue. These Issues will be discussed publicly in that Issue and will help shape the development of the book.</p>"},{"location":"CONTRIBUTING/#book-text","title":"Book text","text":"<p>Book text suggestions are suggested textual changes to the book.</p> <p>To suggest these, either create an Issue or submit a Pull Request.</p> <p>These Issues and Pull Requests will be discussed publicly and accepted if they are judged to improve the book. Of course, 'to improve the book' is subjective.</p> <p>Here are things that are likely to be accepted:</p> <ul> <li>Fixing typo's</li> <li>Simplify wording and/or sentences</li> </ul> <p>Here are things that are unlikely to be accepted:</p> <ul> <li>Anything that breaks a continuous integration test</li> <li>Anything that makes the continuous integration test suite less strict</li> <li>Anything that makes existing tests less strict</li> <li>In-depth technical explanations at a too early chapter</li> </ul>"},{"location":"CONTRIBUTING/#code","title":"Code","text":"<p>Code suggestions are suggested changes to the Rust code.</p> <p>To suggest these, either create an Issue or submit a Pull Request.</p> <p>These Issues and Pull Requests will be discussed publicly and accepted if they are judged to improve the code. Of course, 'to improve the code' is subjective.</p> <p>Here are things that are likely to be accepted:</p> <ul> <li>Removing use of <code>mut</code> for read-only operations</li> <li>Using a more elegant construct that is just as readable</li> </ul> <p>Here are things that are unlikely to be accepted:</p> <ul> <li>Anything that breaks a continuous integration test</li> <li>Anything that reduces code coverage below 100%</li> <li>Anything that makes the continuous integration test suite less strict</li> <li>Anything that makes existing tests less strict</li> <li>Using a faster, yet less readable alternative</li> </ul>"},{"location":"chapters/add_camera/","title":"2.7. Add camera","text":"<p>In this chapter, we add adding a camera to our test suites.</p> <p></p> <p>This chapter introduces:</p> <ul> <li>the Bevy <code>Camera2d</code> bundle</li> <li>a local closure</li> </ul>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#271-first-test","title":"2.7.1.  First test","text":"<p>Similar to earlier chapters, the test starts with counting the number of cameras:</p> <pre><code>fn test_empty_app_has_no_cameras() {\n    let mut app = App::new();\n    app.update();\n    assert_eq!(count_n_cameras(&amp;mut app), 0);\n}\n</code></pre>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#272-first-fix","title":"2.7.2.  First fix","text":"<p>Similar to a <code>Text</code> component, we take a look at the Bevy documentation on the Camera2d and look for a field that feels unique. The <code>camera</code> field, of type <code>Camera</code> is enough to make the test pass:</p> <pre><code>fn count_n_cameras(app: &amp;mut App) -&gt; usize {\n    let mut query = app.world_mut().query::&lt;&amp;Camera&gt;();\n    return query.iter(app.world()).len();\n}\n</code></pre> <p>Also here, the assumption is that other Bevy plugins do not add their own <code>Camera</code>s. As long as it is the case that our camera is the only <code>Camera</code>, this implementation is good enough and does not need a marker component.</p>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#273-second-test","title":"2.7.3.  Second test","text":"<p>Our game will have a camera with a custom scale. Instead of repeating the smaller steps as in the earlier chapters, here we test many new things as one:</p> <pre><code>fn test_create_app_uses_camera_scale() {\n    let initial_camera_scale = 1.2;\n    let mut app = create_app(initial_camera_scale);\n    assert_eq!(count_n_cameras(&amp;mut app), 1);\n    assert_eq!(get_camera_scale(&amp;mut app), initial_camera_scale);\n}\n</code></pre> <p>In TDD, one should have many small tests and only add one tests that breaks at the same time. However, to save book pages, I've combined the three tests into one.</p> <p>Similar to the 'Add a player sprite' chapter, we do not need to add <code>app.update()</code> between creating the <code>App</code> and running the tests, as <code>create_app</code> will do so. Also here, when running our game normally, our game will work as expected.</p>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#274-second-fix","title":"2.7.4.  Second fix","text":"<p>To fix all this, we need to:</p> <ul> <li>write a <code>create_app</code> function that uses our desired camera scale   and add a camera with that scale</li> <li>write a <code>get_camera_scale</code> function that reads the camera's scale</li> </ul> <p>The <code>create_app</code> function is similar to earlier versions:</p> <pre><code>pub fn create_app(initial_camera_scale: f32) -&gt; App {\n    let mut app = App::new();\n    let add_camera_fn = move |mut commands: Commands| {\n        let mut bundle = Camera2d::default();\n        bundle.projection.scale = initial_camera_scale;\n        commands.spawn(bundle);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app\n}\n</code></pre> <p>One difference is the use of a local closure: instead of writing a new function called -for example- <code>add_camera</code>, the things that it would need to do are written in the closure's body. Using a dedicated <code>add_camera</code> function could be considered better readable and clearer (hence, used more often in this book), it is useful to at least having seen the same approach with a local closure.</p> <p>Using a</p> <p></p> <p>Writing the <code>get_camera_scale</code> is also similar to earlier functions:</p> <pre><code>fn get_camera_scale(app: &amp;mut App) -&gt; f32 {\n    let mut query = app.world_mut().query::&lt;&amp;OrthographicProjection&gt;();\n    let projection = query.single(app.world());\n    projection.scale\n}\n</code></pre> <p>Here, we query for the same <code>projection</code> field of a <code>Camera2d</code> of data type <code>OrthographicProjection</code> as we've used in the <code>create_app</code> function.</p>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#275-third-tests","title":"2.7.5.  Third tests","text":"<p>We do want to be able to see something. Hence, we'll probably want to add a player with or without a texture. I've picked to add a player in the same way as chapter <code>add_player</code> and re-used the same tests and implementations.</p>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#276-running-main","title":"2.7.6. Running <code>main</code>","text":"<p>As our <code>create_app</code> now also adds a camera, the <code>main</code> function simplifies to:</p> <pre><code>fn main() {\n    let initial_camera_scale = 0.2;\n    let mut app = create_app(initial_camera_scale);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p></p>","tags":["chapter","add","camera"]},{"location":"chapters/add_camera/#277-conclusion","title":"2.7.7. Conclusion","text":"<p>We can now create an <code>App</code> with a camera. When running the <code>App</code>, a rectangle is displayed. We have tested everything that the App does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_add_camera.</p>","tags":["chapter","add","camera"]},{"location":"chapters/add_player/","title":"2.3. Add player","text":"<p>This chapter shows how to add a player to a game.</p> <p></p> <p>This chapter introduces:</p> <ul> <li>The <code>count_n_players</code> function</li> <li><code>mut</code>-correctness</li> <li>A Bevy <code>Query</code></li> <li>A Bevy <code>Component</code></li> <li>A marker component</li> <li>A Bevy <code>System</code></li> <li>A Bevy entity</li> </ul>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#231-first-test-an-empty-app-has-no-players","title":"2.3.1.  First test: an empty <code>App</code> has no players","text":"<p>First, we test that there are zero players in an empty <code>App</code>. We could call the function <code>count_number_of_players</code>. However, it is all too common to abbreviate 'number of' by an <code>n</code>, resulting in the function name <code>count_n_players</code>:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let app = App::new(); // Note 1: Need mut later\n    app.update(); // Note 2: always update before testing\n    assert_eq!(count_n_players(&amp;app), 0);\n}\n</code></pre> <p>The error will be that the <code>count_n_players</code> function is absent.</p> <p>The comment <code>Note 1</code> is to foreshadow that an <code>App</code> needs to be mutable to have its amount of players counted. It is unexpected that a read-only operation (i.e. counting the amount of players) requires the data it works on to be mutable. The Bevy library, however, has good reasons why <code>App</code> must be mutable: also reading data need to be done in a safe way.</p> <p>In general, a read-only operation should be able to work on an immutable data structure: when, for example, getting the name of a person structure (a read-only operation), we do not expect the person to change and we expect to be able to do so on an immutable person. Correct use the Rust keyword <code>mut</code> is what I call <code>mut</code>-correctness, which is similar to C++ const correctness, where the C++ <code>const</code> keyword indicates something immutable. In C++, it is recommended to be const correct <code>[C++ FAQ][Cline et al., 1998][Eckel, 2000][Lakos, 1996][Sutter, 2004]</code>. As there is no reason why Rust would be different in this regard, this book strives to be <code>mut</code>-correct (and please, contact me if you can share a <code>mut</code>-correct implementation of <code>count_n_players</code>).</p> <p>The comment <code>Note 2</code> is to remind us to always call <code>app.update()</code> before testing. An <code>app.update()</code> lets Bevy initialize an <code>App</code> and it will give false results to do tests on uninitialized <code>App</code>s. Maybe this test will pass without initialization, but it would be an improperly conducted test.</p> <p>To put <code>app.update()</code> at the end of the <code>create_app</code> function is a good idea in some contexts, as it means we do not need to call <code>app.update()</code> in each test. A drawback of calling <code>app.update()</code> in a <code>create_app</code> function is that it does finalize the creation of our <code>App</code>: we cannot -for example- add another player to our created <code>App</code>. The decision strategy in this book is, that if <code>app.update()</code> can be put in <code>create_app</code>, it is put there.</p>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#232-first-fix","title":"2.3.2.  First fix","text":"<p>In test-driven development, one needs to write minimal fixes to tests. Hence, this would be a valid fix:</p> <pre><code>fn count_n_players(app: &amp;App) -&gt; usize {\n    0\n}\n</code></pre>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#233-second-test-a-player-exists","title":"2.3.3.  Second test: a <code>Player</code> exists","text":"<p>Before we start counting actual players, let's write a simple test to make use write a player class.</p> <p>A simple test is:</p> <pre><code>fn test_player_class_exists() {\n    let player: Player;\n}\n</code></pre> <p>This test does not compile yet:</p> <pre><code>error[E0412]: cannot find type `Player` in this scope\n</code></pre> <p>The Rust compiler is correct: we need to define it.</p>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#234-a-player-exists","title":"2.3.4.  a <code>Player</code> exists","text":"<p>Here is the code to fix this:</p> <pre><code>pub struct Player;\n</code></pre>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#235-third-test-a-player-is-a-bevy-component","title":"2.3.5.  Third test: a <code>Player</code> is a Bevy Component","text":"<p>Bevy uses a <code>Component</code> class in most of its functions.</p> <pre><code>fn test_player_class_is_a_bevy_component() {\n    let player = Player;\n    assert!(is_bevy_component(player));\n}\n</code></pre>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#236-third-test-a-player-is-a-bevy-component","title":"2.3.6.  Third test: a <code>Player</code> is a Bevy Component","text":"<pre><code>#[cfg(test)]\nfn is_bevy_component&lt;T: Component&gt;(_t: T) -&gt; bool {\n    true\n}\n</code></pre> <p>Which allows us to write:</p> <pre><code>#[derive(Component)]\npub struct Player;\n</code></pre>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#237-bevy-components","title":"2.3.7. Bevy Components","text":"<p>Going back to this code:</p> <pre><code>#[derive(Component)]\npub struct Player;\n</code></pre> <p>In English this would read: 'a player is a component'. Using more formal language, one would say that the <code>Player</code> structure is an extension of the Bevy <code>Component</code> structure.</p> <p>A Bevy <code>Component</code> is a blueprint for things that can be stored in a Bevy <code>World</code>. Using more formal language, one would say that the Bevy <code>Component</code> is a base class or a Rust trait (we ignore that <code>Component</code> is a bit more complex than this). Components are the workhorse unit in Bevy: you'll create components, query for components and -later- you'll bundle components.</p> <p>There are two types of Bevy components:</p> <ul> <li>marker components</li> <li>regular components</li> </ul> <p>Marker components are Bevy components that are extended with only a name, where a regular components extends a Bevy component with a name and member variables. The <code>Player</code> structure above is a marker component, as it only extends the Bevy <code>Component</code> by adding a name, without having member variables nor member functions.</p>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#233-second-test-our-app-has-one-player","title":"2.3.3.  Second test: our <code>App</code> has one player","text":"<p>Now that we can count the number of players, we can test that the <code>App</code> we create has one player:</p> <pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre> <p>This will fail, as <code>create_app</code> does not create an <code>App</code> with a player yet.</p>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#234-second-fix","title":"2.3.4.  Second fix","text":"<p>Adding our <code>Player</code> <code>Component</code> to our <code>App</code> takes two steps:</p> <ul> <li>Write an <code>add_player</code> function</li> <li>Let the <code>create_app</code> function call the <code>add_player</code> function</li> </ul> <p>Here is the <code>create_app</code> function:</p> <pre><code>pub fn create_app() -&gt; App {\n    let mut app = App::new();\n    app.add_systems(Startup, add_player);\n    app\n}\n</code></pre> <p>The new line introduces us to the Bevy <code>System</code> and reads as 'in the startup phase, run the <code>add_player</code> function'.</p> <p>In Bevy, a 'system' is -loosely phrased- 'something that works on the world'. This 'something' is typically a function.</p> <p>The word 'Startup' is the name of a so-called schedule, i.e. it indicates when the system should be run. In our case, the system should be run at startup.</p> <p>Our <code>create_app</code> functions adds a system, called <code>add_player</code>, that is run at the startup phase of the application, then returns our <code>App</code>.</p> <p>Here is the <code>add_player</code> function:</p> <pre><code>fn add_player(mut commands: Commands) {\n    commands.spawn(Player);\n}\n</code></pre> <p>This function has some magic to it:</p> <ul> <li><code>mut commands: Commands</code>: this function argument is provided by Bevy.   The <code>Commands</code> structure allows on the modify the Bevy world.</li> <li>`commands.spawn(Player add the entity of type Player to the world</li> </ul> <p>After having modified <code>create_app</code>, added the <code>Player</code> <code>Component</code> and the <code>add_player</code> function, the test passes. Well done!</p> <p>An alternative implementation would be to combine the statements above, resulting in:</p> <pre><code>app.add_systems(Startup, |mut commands: Commands| {\n    commands.spawn(Player);\n});\n</code></pre> <p>This implementation does exactly the same. One could argue that it is harder to understand what this does, where the function name <code>add_player</code> was communicated this clearly. One could argue that the expression is more complex, as it introduces a closure (more on those later). This book picked the way that is easier to explain. This approach also scales better when adding players, enemies, cameras, etcetera.</p> <pre><code>fn count_n_players(app: &amp;mut App) -&gt; usize {\n    let mut query = app.world_mut().query::&lt;&amp;Player&gt;();\n    query.iter(app.world()).len()\n}\n</code></pre> <p>This implementation is a simple way to count the amount of <code>Player</code> components. Here I break down the implementation:</p> <ul> <li><code>let mut query</code>: we create a question to ask to Bevy.   In the context of informatics, a question such as this is called 'a query'.   The query will be actively used in the next step, hence it must be mutable</li> <li><code>app.world_mut()</code> denotes that we need mutable (i.e. read and write)   access to the <code>World</code> structure of a Bevy <code>App</code>. Unsurprisingly,   the <code>World</code> structure holds all things that are part of the world   in your game.</li> <li><code>.query::&lt;&amp;Player&gt;()</code> reads as '(from a world, ) get all the players'.   To be precise: we queried the Bevy world for all entities of the <code>Player</code> <code>Component</code>. We will explain entities and components   later; for now, the code <code>Player</code> is related to a   component (whatever that is) for a player.</li> <li><code>query.iter(app.world())</code> reads as 'iterate over the   answers of our question (applied to our -now immutable!- world)'</li> <li><code>.len()</code> is for counting the amount of players that are found</li> </ul> <p>The Bevy <code>Query</code> is the workhorse for reading and writing to your game world and it is very flexible: you'll see many queries in different forms in this book.</p> <p>As querying in Bevy requires the <code>App</code> to be mutable, the <code>App</code> used in the tests needs to be mutable too. This is the test we'll end up with:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#235-mainrs","title":"2.3.5. <code>main.rs</code>","text":"<p>To run our application, we need not change our <code>main</code> function, it still looks like this:</p> <pre><code>fn main() {\n    let mut app = create_app();\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p></p>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#236-conclusion","title":"2.3.6. Conclusion","text":"<p>We can now create an <code>App</code> with one player.</p> <p>We encountered all elements of the ECS paradigm that Bevy follows:</p> <ul> <li>Entity: an instance of a Component</li> <li>Component: a structure definition of something that can be used a in Bevy world</li> <li>System: a function that works on a Bevy world</li> </ul> <p>We have tested everything that the App does!</p> <p>The full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_add_player.</p>","tags":["chapter","add","player"]},{"location":"chapters/add_player/#237-references","title":"2.3.7. References","text":"<ul> <li><code>[C++ FAQ]</code> C++ FAQ, question What is \u201cconst correctness\u201d?, accessed 2024-06-14. Answer: 'A good thing.'</li> <li><code>[Cline et al., 1998]</code> Marshall Cline, Greg Lomow and Mike Girou. C++ FAQs, second edition. 1998. ISBN: 0-201-3098301. FAQ 14.05: 'Is const correctness tedious?' (Answer: no).</li> <li><code>[Eckel, 2000]</code> Bruce Eckel. Thinking in C++, second edition, volume 1. 2000. ISBN: 0-13-979809-9. Item 8: 'Constants', paragraph 'Summary': 'const-correctness can be a lifesaver for projects'.</li> <li><code>[Lakos, 1996]</code> John Lakos. Large-Scale C++ Software Design. 1996. ISBN: 0-201-63362-0. Chapter 9.1.6: 'Every object in a system should be const-correct'</li> <li><code>[Sutter, 2004]</code> Herb Sutter. Exceptional C++ style. 2005. ISBN: 0-201-76042-8. Item 1 guideline: 'Be const correct'.</li> </ul>","tags":["chapter","add","player"]},{"location":"chapters/add_player_sprite/","title":"2.4. Add player sprite","text":"<p>This chapter shows how to add a player sprite to a game, at a certain position and of a certain size, starting from scratch again.</p> <p></p> <p>Bevy supports 2D, isometric ('2.5D') and 3D. For simplicity, the game we develop is 2D.</p> <p>In this chapter, there are many good ways to the code. I picked the route that has no rewrites of old code in it, as this would best fit a book.</p> <p>This chapter introduces:</p> <ul> <li>closures</li> <li>a Bevy <code>Transform</code></li> <li>an in-function assertion</li> </ul>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#241-first-test-our-app-needs-a-position-and-size","title":"2.4.1.  First test: our <code>App</code> needs a position and size","text":"<p>If we want to add a player sprite to the game at a certain position and of a certain size, our <code>App</code> needs to know.</p> <p>Our first test forces us to supply this information in the <code>create_app</code> function:</p> <pre><code>fn test_can_create_app() {\n    let initial_player_position = Vec2::new(0.0, 0.0);\n    let initial_player_size = Vec2::new(64.0, 32.0);\n    create_app(initial_player_position, initial_player_size);\n}\n</code></pre> <p>As the game we create is 2D, both a position and a size are two dimensional.</p> <p>The test is generous: calling <code>create_app</code> must be possible with two arguments, after which it should not crash.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#242-first-fix","title":"2.4.2.  First fix","text":"<p>A valid stub would be:</p> <pre><code>fn create_app(_position: Vec2, _size: Vec2) -&gt; App {\n  App::new()\n}\n</code></pre> <p>The variable names starting with an underscore (<code>_</code>) denote that their values are allowed to be unused. This is perfect for a stub!</p> <p>One could argue that one should do a complete implementation and store the position and size of the player somewhere. There are plenty of ways to do so, including quite unconventional ones. A consequence of doing TDD is a clean (and conventional) software architecture. Instead of doing funky things, settling for a stub is -as always!- perfectly fine.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#243-second-test-an-empty-app-has-no-players","title":"2.4.3.  Second test: an empty <code>App</code> has no players","text":"<p>Next step is to count the number of players of an empty <code>App</code>, so we have a reason to add a player. We did the same last chapter too.</p> <p>Here is the code:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre> <p>This is the last time I will repeat tests that are identical to earlier chapters: it is not worth the space in a book.</p> <p>The fix is identical to the one shown in the previous chapter:</p> <ol> <li>create the <code>count_n_players</code> function</li> <li>implement the <code>Player</code> marker component</li> </ol>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#244-third-test-our-app-has-a-player","title":"2.4.4.  Third test: our <code>App</code> has a player","text":"<p>A slightly new test is to determine if <code>create_app</code>, now with two arguments, indeed creates one player:</p> <pre><code>fn test_create_app_has_a_player() {\n    let initial_player_position = Vec2::new(0.0, 0.0);\n    let initial_player_size = Vec2::new(64.0, 32.0);\n    let mut app = create_app(initial_player_position, initial_player_size);\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre> <p>This test has no <code>app.update()</code> between creating the <code>App</code> and running the tests, as <code>create_app</code> will do so. In this case, when running our game normally, our game will work as expected.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#245-third-fix","title":"2.4.5.  Third fix","text":"<p>To fix this test, we need:</p> <ul> <li>[x] a <code>Player</code> marker component: done in the previous test</li> <li>[ ] a way to add a player with a certain position and size</li> <li>[ ] create a player sprite</li> <li>[ ] a way to store the player position and size in that sprite</li> </ul> <p>The <code>Player</code> marker component already has been created in the previous test, when counting the amount of players.</p> <p>The way to add a player with a certain position and size is to forward this problem to the <code>add_player</code> function: we'll implement the <code>add_player</code> function soon, but we'll start assuming that it does not only take <code>Commands</code> as an arguments, but also a player's position and size:</p> <pre><code>pub fn create_app(initial_player_position: Vec2, initial_player_size: Vec2) -&gt; App {\n    let mut app = App::new();\n    let add_player_fn = move |commands: Commands| {\n        add_player(commands, initial_player_position, initial_player_size);\n    };\n    app.add_systems(Startup, add_player_fn);\n    app.update();\n    app\n}\n</code></pre> <p>One can see that indeed <code>add_player</code> is called with three arguments (<code>commands</code>, <code>initial_player_position</code> and <code>initial_player_size</code>). However, that function call is wrapped inside of a closure. That closure is called <code>add_player_fn</code>, where <code>fn</code> is a common abbreviation of 'function'. We need this closure as a bridge between what we need (i.e. a function with three function arguments) to what Bevy needs (i.e. a function with one function argument).</p> <p>Creating a player sprite and storing the player's position and size is done in the <code>add_player</code> function:</p> <pre><code>fn add_player(mut commands: Commands, initial_player_position: Vec2, initial_player_size: Vec2) {\n    commands.spawn((\n        Sprite {\n            transform: Transform {\n                translation: Vec2::extend(initial_player_position, 0.0),\n                scale: Vec2::extend(initial_player_size, 1.0),\n                ..default()\n            },\n            ..default()\n        },\n        Player,\n    ));\n}\n</code></pre> <p>Here I unpack <code>add_player</code>:</p> <ul> <li><code>commands.spawn((...,...))</code>: adds a new entity that is a tuple of two things</li> <li><code>Sprite { ... }</code>: adds a Bevy <code>Sprite</code></li> </ul> <p></p> <p>Part of the Bevy Sprite documentation</p> <ul> <li><code>transform: Transform { ... }, ..default()</code>: initialize the <code>transform</code> field   of the <code>Sprite</code>, leave the rest at default values</li> <li><code>translation: ..., scale: ..., ..default()</code>:   initialize the <code>translation</code> and <code>scale</code> fields with particular value,   keeping the others at default values. A translation is a relative (3D)   movement compared to the origin (i.e, at coordinate <code>(0, 0, 0)</code>)</li> <li><code>Vec2::extend(initial_player_position, 0.0)</code>: create a 3D coordinate,   by extending our 2D position with a z coordinate of zero</li> <li><code>Vec2::extend(initial_player_size, 1.0)</code>: create a 3D scale of the sprite,   by extending our 2D size with a z scale of one. A z scale of one means that   the sprite will have its regular scale</li> </ul> <p>Note that the player's size is stored in the <code>translate</code> field. One could argue that we do not set the player's size, but the player's translation instead, hence the variable <code>initial_player_size</code> should be called <code>initial_player_translation</code>. However, in this context, we (and our other users) do want to set the player's translation and we should ignore that in the implementation details we need to modify a translation. This is a good feature of TDD: it prevents us from using needlessly technical names.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#246-fourth-test-a-player-has-a-position","title":"2.4.6.  Fourth test: a player has a position","text":"<p>Our previous implementation could (and maybe should) have been done sloppier. Here we enforce that the player's 2D position is implemented correctly:</p> <pre><code>fn test_get_player_position() {\n    let initial_player_position = Vec2::new(1.2, 3.4);\n    let initial_player_size = Vec2::new(64.0, 32.0);\n    let mut app = create_app(initial_player_position, initial_player_size);\n    assert_eq!(get_player_position(&amp;mut app), initial_player_position);\n}\n</code></pre>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#247-fourth-fix","title":"2.4.7.  Fourth fix","text":"<p>Here is an implementation to get back the player's position from the complex thing we added:</p> <pre><code>fn get_player_position(app: &amp;mut App) -&gt; Vec2 {\n    let mut query = app.world_mut().query::&lt;(&amp;Transform, &amp;Player)&gt;();\n    let (transform, _) = query.single(app.world());\n    assert_eq!(transform.translation.z, 0.0); // 2D\n    transform.translation.xy()\n}\n</code></pre> <p>The function is now a bit more complex.</p> <p>The query now has <code>(&amp;Transform, &amp;Player)</code> tuple in its template arguments. The English, the query would read as: 'let me ask for all entities that have both a <code>Transform</code> and a <code>Player</code> component'. The <code>Transform</code> component is one of the 7-9 components of a <code>Sprite</code>, which we will need to get the <code>translate</code> field of. The <code>Player</code> component is our own marker component, that now actually marks something: it marks which <code>Transform</code> belongs to the player. A <code>Transform</code> is a Bevy component that is used for other things too, among others, the position of the camera. Due to this, we cannot query only for <code>Transform</code>, as there will be more <code>Transform</code>s in our application.</p> <p>As we asked for a query matching the tuple <code>(&amp;Transform, &amp;Player)</code>, our (single, thanks to <code>single</code>) result will be of the same type. Of that tuple, we only keep the <code>Transform</code> and ignore the (empty) <code>Player</code>.</p> <p>Of the <code>Transform</code>, we assume that the z coordinate is zero: we are working on a 2D game after all! Instead of only assuming this to be true, we can let Rust confirm this for real. The <code>assert</code> macros exist to do exactly that. Hence, instead of commenting or documenting that the z coordinate is zero, we <code>assert</code> this to be so. Use assertions to document you assumptions <code>[Lakos, 1996]</code> <code>[McConnell, 2004a]</code> <code>[Stroustrup, 1997]</code> <code>[Sutter &amp; Alexandrescu, 2004]</code>. Use assertions liberally <code>[Liberty, 2001]</code> <code>[Stroustrup, 2012]</code>.</p> <p>Of the 3D <code>Transform</code> (with a z coordinate of zero), we return the x and y coordinate of the translation.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#248-fifth-test-a-player-has-a-size","title":"2.4.8.  Fifth test: a player has a size","text":"<p>Now we can work with a player's position, we do the same for a player's size:</p> <pre><code>fn test_player_has_a_custom_size() {\n    let initial_player_position = Vec2::new(1.2, 3.4);\n    let initial_player_size = Vec2::new(64.0, 32.0);\n    let mut app = create_app(initial_player_position, initial_player_size);\n    assert_eq!(get_player_size(&amp;mut app), initial_player_size);\n}\n</code></pre> <p>This test is nearly identical to the previous test, except now for using <code>get_player_size</code> and comparing it to the initial player size.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#249-fifth-fix","title":"2.4.9.  Fifth fix","text":"<p>The fix is nearly identical to the previous one:</p> <pre><code>fn get_player_size(app: &amp;mut App) -&gt; Vec2 {\n    let mut query = app.world_mut().query::&lt;(&amp;Transform, &amp;Player)&gt;();\n    let (transform, _) = query.single(app.world());\n    assert_eq!(transform.scale.z, 1.0); // 2D\n    transform.scale.xy()\n}\n</code></pre> <p>This time, we assert that the player's scale is one, which is needed for (the correct rendering of) a 2D game.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#2410-mainrs","title":"2.4.10. <code>main.rs</code>","text":"<p>All our tests pass! However, we have not yet seen the player. To see our game in action, we need to actually run the game. Here is a <code>main</code> function:</p> <pre><code>fn main() {\n    let initial_player_position = Vec2::new(0.0, 0.0);\n    let initial_player_size = Vec2::new(64.0, 32.0);\n    let mut app = create_app(initial_player_position, initial_player_size);\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p>New to this <code>main</code> function is adding a camera, again using a closure. The camera is needed to display a sprite. Without the camera, we will see nothing at all. In chapter the chapter 'Add a camera' we will add this camera in a TDD way.</p> <p>This is how our game looks like now:</p> <p></p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#2410-conclusion","title":"2.4.10. Conclusion","text":"<p>We can now create an <code>App</code> with one player sprite, where the player has, among others, a position and size. When running the <code>App</code>, we can see the player. We have tested everything that the App does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_add_player_sprite.</p>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite/#2411-references","title":"2.4.11. References","text":"<ul> <li><code>[Lakos, 1996]</code> John Lakos. Large-Scale C++ Software Design. 1996. ISBN: 0-201-63362-0. Chapter 2.6: 'The use of assert statements can help to document the assumptions you make when implementing your code</li> <li><code>[Liberty, 2001]</code> Jesse Liberty. Sams teach yourself C++ in 24 hours, 2nd edition. 2001. ISBN: 0-672-32224-2. Hour 24, chapter 'assert()': 'Use assert freely'</li> <li><code>[McConnell, 2004a]</code> Steve McConnell. Code Complete (2nd edition). 2004. ISBN: -735619670. Chapter 8.2 'Assertions', paragraph 'Guidelines for using asserts': 'Use assertions to document and verify preconditions and postconditions'</li> <li><code>[McConnell, 2004b]</code> Steve McConnell. Code Complete (2nd edition). 2004. ISBN: -735619670. Chapter 8.2 'Assertions', paragraph 'Guidelines for using asserts': 'Use assertions for conditions that should never occur'.</li> <li><code>[Stroustrup, 1997]</code> Bjarne Stroustrup. The C++ Programming Language (3rd edition). 1997. ISBN: 0-201-88954-4. Advice 24.5.18: 'Explicitly express preconditions, postconditions, and other assertions as assertions'</li> <li><code>[Stroustrup, 2012]</code> Bjarne Stroustrup. The C++ Programming Language (4th edition). 2013. ISBN: 978-0-321-56384-2. Chapter 30.5. Advice. page 884: '[13] Use static_assert() and assert() extensively'</li> <li><code>[Sutter &amp; Alexandrescu, 2004]</code> Herb Sutter, Andrei Alexandrescu. C++ coding standards: 101 rules, guidelines, and best practices. ISBN: 0-32-111358-6. Chapter 68: 'Assert liberally to document internal assumptions and invariants'</li> </ul>","tags":["chapter","add","player","sprite"]},{"location":"chapters/add_player_sprite_with_texture/","title":"2.5. Add player sprite with a texture","text":"<p>This chapter shows how to add a player sprite with a texture to a game. This allows us to use images in our game.</p> <p></p> <p>This chapter introduces:</p> <ul> <li>The Bevy <code>Handle</code></li> <li>The Bevy <code>Image</code></li> <li><code>cfg!(test)</code>, an <code>if</code> statement only true during testing</li> <li>Adding the <code>AssetPlugin</code> and <code>TaskPoolPlugin</code></li> <li>Initializing a Bevy image</li> <li>Where to put assets (i.e. images, sounds, etc.)</li> <li>Loading an image from file using <code>AssetServer</code></li> </ul> <p></p>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#251-first-tests","title":"2.5.1.  First tests","text":"<p>Our first tests are the same as in earlier chapters, forcing us to write <code>create_app</code>, <code>count_n_players</code> and the <code>Player</code> component:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n\nfn test_our_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre> <p>See the 'Add a player' chapter for the implementations and an in-depth discussion.</p> <p>There is one big difference in these tests: <code>app.update</code> is called in each test! In all earlier chapters, we called <code>app.update</code> at the end of the <code>create_app</code> function. In this chapter, we don't, because doing so finalizes the <code>App</code> too early and this will cause that our game to panic in the <code>main</code> function (hence we cannot play the game). This will be discussed in both the <code>create_app</code> and the <code>main</code> function paragraph.</p>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#252-third-test-our-player-has-a-default-scale","title":"2.5.2.  Third test: our player has a default scale","text":"<p>In the 'Add a player sprite' chapter the size of the player's sprite was set to its size (i.e width and height) in pixels, using the <code>scale</code> of a player's <code>Transform</code>. In that context, <code>scale</code> is a misnomer: it indicates the size of the player (and not the scale).</p> <p>When using an image, 'scale' is nicely named: an image has its inherent size in pixels, where <code>scale</code> will scale the image up or down. When the scale is set to one, an image will be displayed at its original 1:1 scale. In Bevy, a scale has three dimensions.</p> <p>Here we test that the scale of our image is one in both two dimensions, as we are working on as 2D game. We will later assert that the scale in the third dimension is one too.</p> <p>Here is the test:</p> <pre><code>fn test_player_has_the_default_scale() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_scale(&amp;mut app), Vec2::new(1.0, 1.0));\n}\n</code></pre>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#253-third-fix","title":"2.5.3.  Third fix","text":"<p>Although the function name <code>get_player_scale</code> is new, it has exactly the same implementation as <code>get_player_size</code> in the previous chapter:</p> <pre><code>fn get_player_scale(app: &amp;mut App) -&gt; Vec2 {\n    let mut query = app.world_mut().query::&lt;(&amp;Transform, &amp;Player)&gt;();\n    let (transform, _) = query.single(app.world());\n    assert_eq!(transform.scale.z, 1.0); // 2D\n    transform.scale.xy()\n}\n</code></pre> <p>In the context of using an image, it is more natural to work with a scale than with a size.</p>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#254-fourth-test-our-player-has-a-texture","title":"2.5.4.  Fourth test: our player has a texture","text":"<p>Now for the texture:</p> <pre><code>fn test_player_has_a_texture() {\n    let mut app = create_app();\n    app.update();\n    assert!(get_player_has_texture(&amp;mut app));\n}\n</code></pre>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#255-fourth-fix","title":"2.5.5.  Fourth fix","text":"<p>The seemingly innocent test above, forces us into a complex fix:</p> <ul> <li>Write the <code>get_player_has_texture</code> function</li> <li>Modify the <code>create_app</code> function</li> <li>Write the <code>add_player</code> function</li> </ul> <p>The <code>get_player_has_texture</code> function contains a query similar to what we know:</p> <pre><code>fn get_player_has_texture(app: &amp;mut App) -&gt; bool {\n    let mut query = app.world_mut().query::&lt;(&amp;Sprite, &amp;Player)&gt;();\n    let (sprite, _) = query.single(app.world());\n    sprite.image.is_strong()\n}\n</code></pre> <p>There are two new elements:</p> <ul> <li><code>&amp;Handle&lt;Image&gt;</code>: this reads as 'a handle to an image'.   This data type is chosen from   the Bevy documentation of <code>Sprite</code>   (see below),   as it is the data type of the <code>Sprite</code> field called <code>texture</code>.   A 'handle to an image' is a lightweight way to work with images, similar   to the Rust <code>box</code> class: both can be copied and cloned and ... empty</li> <li><code>handle.is_strong()</code> determines if the handle indeed refers to an image   that is actually (being) loaded</li> </ul> <p></p> <p>Part of the Bevy Sprite documentation</p> <p>The <code>create_app</code> function may look like this:</p> <pre><code>pub fn create_app() -&gt; App {\n    let mut app = App::new();\n\n    if cfg!(test) {\n        app.add_plugins(AssetPlugin::default());\n        app.add_plugins(TaskPoolPlugin::default());\n        app.init_asset::&lt;bevy::image::Image&gt;();\n    }\n    app.add_systems(Startup, add_player);\n\n    app\n}\n</code></pre> <p>The <code>if</code> statement and its body are new, I unpack it here:</p> <ul> <li><code>if cfg!(test) { ... }</code> is read as 'when running tests, run the code   between curly brackets'. This means that this code is ignored when   running our game from the <code>main</code> function</li> <li><code>app.add_plugins(AssetPlugin::default())</code>: add the default <code>AssetPlugin</code></li> <li><code>app.add_plugins(TaskPoolPlugin::default())</code>: add the default <code>TaskPoolPlugin</code></li> <li><code>app.init_asset::&lt;bevy::render::texture::Image&gt;()</code>: initialize the <code>Image</code>   asset</li> </ul> <p>A plugin is a combination of entities, components and systems that work together to achieve a goal. It is a unit of modularity: you can put these in a Rust crate and become part of the Bevy ecosystem.</p> <p>With the <code>AssetPlugin</code> present, we need to initialize it to allow for working with images. Note that one only needs to remember to add the <code>AssetPlugin</code>: the following two lines were copied from helpful error messages.</p> <p>Adding the default plugins (called <code>DefaultPlugins</code>) seems like a good idea: one can be sure that the most important plugins are present. The problem with this, however, is that will turn our program into a full-blown application with a window that needs to be closed by a user. Our tests should run without user input, hence we cannot use all the default plugins. Instead, we only add the plugins we need for testing in a build that runs the test.</p> <p>The reason why we do not add <code>app.update()</code> to the <code>create_app</code> function is because of the <code>if cfg!(test)</code>: as a consequence of this if statement, running the tests will differ from running the game: the test build will have two plugins added and one asset initialized, where this will not be done when running the game normally. When running the game normally with an <code>app.update()</code> in the end, the program will panic, because <code>add_player</code> is called without the needed plugins. This problem is solved by, in <code>main</code>, adding the (many more) plugins there.</p> <p>The <code>add_player</code> function may look like this:</p> <pre><code>fn add_player(mut commands: Commands, asset_server: Res&lt;AssetServer&gt;) {\n    commands.spawn((\n        Sprite::from_image(asset_server.load(\"bevy_bird_dark.png\")),\n        Player,\n    ));\n}\n</code></pre> <p>The biggest surprise is the <code>asset_server: Res&lt;AssetServer&gt;</code>: apparently, when adding a Bevy system, one can 'magically' get access to an <code>asset_server</code> of datatype <code>Res&lt;AssetServer&gt;</code>. A <code>Res</code> is a unique Bevy resource, in this case of type <code>AssetServer</code>: a structure for assets.</p> <p>The creation of the player's <code>Sprite</code> is similar too, except for <code>texture: asset_server.load(\"bevy_bird_dark.png\")</code>, where a texture is loaded from file by the assets server. For this to work, that file (in this case, <code>bevy_bird_dark.png</code>) must be present in the <code>assets</code> folder of the Rust project.</p>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#256-mainrs","title":"2.5.6. <code>main.rs</code>","text":"<p>The <code>main</code> function has not changed at all:</p> <pre><code>fn main() {\n    let mut app = create_app();\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p>The reason why we did not add <code>app.update()</code> to the <code>create_app</code> function is because of that we add the default plugins here. Would the plugins from the test build already have been added, this would cause our program to panic: Bevy asserts that a plugin is not added twice. Because the plugins we add in our test build are part of the default plugins added in our <code>main</code> function, we need a mechanism to have the right plugins added to the right build. Only after adding the default plugins here should our <code>App</code> be updated, as calling <code>app.update</code> (which will be done by <code>app.run</code>) will assume that the plugin for the <code>AsserServer</code> is loaded.</p> <p>Here is how our game looks like:</p> <p></p>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_player_sprite_with_texture/#257-conclusion","title":"2.5.7. Conclusion","text":"<p>We can now create an <code>App</code> with a player sprite that has a texture. When running the <code>App</code>, we can see the player. We have tested everything that the App does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_add_player_sprite_with_texture.</p>","tags":["chapter","add","player","sprite","texture"]},{"location":"chapters/add_text/","title":"2.6. Add text","text":"<p>This chapter shows how to add a text to a game.</p> <p></p> <p>This chapter introduces:</p> <ul> <li>Working with Rust <code>String</code>s</li> <li>The Bevy <code>Text2d</code></li> <li>Using <code>app.update()</code> in the wrong place causing problems</li> </ul>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#261-first-test-an-app-has-no-text","title":"2.6.1.  First test: an <code>App</code> has no text","text":"<p>Similar to earlier chapters, we'll start our game development for counting the number of texts to be zero:</p> <pre><code>fn test_empty_app_has_text() {\n    let mut app = App::new();\n    assert_eq!(count_n_texts(&amp;mut app), 0);\n}\n</code></pre> <p>Like in earlier chapters, we already make <code>App</code> mutable, as querying requires the <code>App</code> to be so.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#262-first-fix","title":"2.6.2.  First fix","text":"<p>Part of the Bevy <code>Text2d</code> documentation</p> <p>Taking a look at the Bevy <code>Text2d</code> documentation, one can see that there is a field called <code>text</code> of data type <code>Text</code>. We'll use that -and only that- for our query:</p> <pre><code>fn count_n_texts(app: &amp;mut App) -&gt; usize {\n    let mut query = app.world_mut().query::&lt;&amp;Text2d&gt;();\n    return query.iter(app.world()).len();\n}\n</code></pre> <p>This query is probably (and indeed is!) good enough, as it will not conflict with the Bevy entities that are added by the default plugins. This was different from when we were querying for a player's <code>Transform</code>, as a default camera also has a <code>Transform</code> Component, hence we had to use a <code>Player</code> marker component to get access to the right <code>Transform</code>.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#263-second-test-can-create-an-app-with-text","title":"2.6.3.  Second test: can create an <code>App</code> with text","text":"<p>As our game will show a text, we'll have to be able to pass our desired text to it. We do so using a <code>create_app</code> function:</p> <pre><code>fn test_can_create_app_from_str() {\n    create_app(String::from(\"irrelevant\"));\n}\n</code></pre> <p>The <code>String</code> used by Bevy is the standard Rust <code>String</code>.</p> <p>We could just as well have picked to use a string slice instead, as it would have made our test look cleaner:</p> <pre><code>fn test_can_create_app_from_str_slice() {\n    create_app(\"irrelevant\");\n}\n</code></pre> <p>When trying out if the string slice resulted in cleaner code over using a <code>String</code>, the answer turned out to be no: due to the string slice lifespans it was needed to create <code>String</code>s for them.</p> <p>One could argue that the cleanest looking test should be chosen and, hence, the string slice. However, having a String construction in a test is reasonable enough and because it resulted in a cleaner implementation, using a <code>String</code> was chosen.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#264-second-fix","title":"2.6.4.  Second fix","text":"<p>All that this test forces us to do, is to write a <code>create_app</code> function that accepts a <code>String</code>. Here is an example stub that will pass the test:</p> <pre><code>pub fn create_app(_text: String) -&gt; () {}\n</code></pre>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#265-third-test-an-app-has-text","title":"2.6.5.  Third test: an <code>App</code> has text","text":"<p>Now we force our game to actually store the text in an entity:</p> <pre><code>fn test_app_has_text() {\n    let mut app = create_app(String::from(\"irrelevant\"));\n    app.update();\n    assert_eq!(count_n_texts(&amp;mut app), 1);\n}\n</code></pre> <p>Where the previous chapter needed to have <code>app.update()</code> to prevent a panic, here we have a different reason: would we add <code>app.update()</code> in the <code>create_app</code> function, our text will not be shown in a regular run:</p> <p></p> <p>This game when <code>app.update()</code> is added to <code>create_app</code>: no text is visible</p> <p>The reason is, again, that calling <code>app.update()</code> finalizes the <code>App</code>'s currents state. When then, in the <code>main</code> function, the default plugins are added, something happens to the already initialized text making it not appear.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#266-third-fix","title":"2.6.6.  Third fix","text":"<p>To make this test pass, we need to:</p> <ul> <li>Write <code>create_app</code> to pass on the <code>String</code> to a <code>add_text</code> function</li> <li>Write an <code>add_text</code> function to add a component with that <code>String</code></li> </ul> <p>The <code>create_app</code> is quite similar to versions is earlier chapters:</p> <pre><code>pub fn create_app(text: String) -&gt; App {\n    let mut app = App::new();\n    let add_text_fn = move |commands: Commands| add_text(commands, &amp;text);\n    app.add_systems(Startup, add_text_fn);\n    app\n}\n</code></pre> <p>Also in this incarnation of <code>create_app</code>, we use a closure to be able to fit our <code>add_text</code> function in the <code>app.add_systems</code> member function.</p> <p>The <code>add_text</code> function may look like this:</p> <pre><code>fn add_text(mut commands: Commands, str: &amp;String) {\n    commands.spawn(Text2d::new(str));\n}\n</code></pre> <p>Most of this function is similar to adding a <code>Sprite</code>. It may come as a surprise that the <code>text</code> field is more than just a <code>String</code>: a <code>Text</code> contains multiple <code>TextSection</code>s, of which each <code>TextSection</code> can have its own text and style.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#267-fourth-test-an-app-has-the-correct-text","title":"2.6.7.  Fourth test: an <code>App</code> has the correct text","text":"<p>In the final test we assure that our desired text is actually stored by our application:</p> <pre><code>fn test_app_uses_text() {\n    let text = String::from(\"some random text\");\n    let mut app = create_app(text.clone());\n    app.update();\n    assert_eq!(get_text(&amp;mut app), text);\n}\n</code></pre> <p>In this test, our <code>text</code> string needs to be cloned and the Rust compiler will remind us of that.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#268-fourth-fix","title":"2.6.8.  Fourth fix","text":"<p>If your implementations matched the earlier fixes, this test would already pass. In case you've cut a corner, this is the test that will force you to write a non-stub implementation.</p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#269-mainrs","title":"2.6.9. <code>main.rs</code>","text":"<p>The resulting <code>main</code> function is not much different than we are used to:</p> <pre><code>fn main() {\n    let text = String::from(\"Hello from main\");\n    let mut app = create_app(text);\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p></p>","tags":["chapter","add","text"]},{"location":"chapters/add_text/#2610-conclusion","title":"2.6.10. Conclusion","text":"<p>We can now create an <code>App</code> with a text. We have tested everything that the App does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_add_text.</p>","tags":["chapter","add","text"]},{"location":"chapters/click_sprite/","title":"Respond to clicking on a sprite","text":"<p>This page is a stub.</p> <pre><code>fn main() {\n    let mut app = create_app();\n    app.run();\n}\n</code></pre>","tags":["respond","click","sprite"]},{"location":"chapters/hello_world/","title":"2.2. Hello world","text":"<p>This chapter is about creating a minimal Bevy program that is completely tested.</p> <p></p> <p>This chapter introduces:</p> <ul> <li>The Bevy <code>App</code></li> <li>Test-Driven Development ('TDD')</li> <li>Types of implementations</li> <li>Code coverage.</li> <li>The <code>create_app</code> function</li> </ul>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#221-test-driven-development","title":"2.2.1. Test-Driven Development","text":"<p>Test-Driven Develop, or TDD, is a software methodology to develop computer code in a systematic way, that is known to improve code quality <code>[Alkaoud &amp; Walcott, 2018]</code> <code>[Janzen &amp; Saiedian, 2006]</code>.</p> <p>To develop code with TDD, one does many, usually short (think minutes!) TDD cycles. A TDD cycle has three steps:</p> <ul> <li>Red: write a test that breaks the code</li> <li>Green: fix the test</li> <li>Blue: cleanup</li> </ul> <pre><code>flowchart TD\n  classDef red_node fill:#fdd,color:#000,stroke:#f00\n  classDef green_node fill:#dfd,color:#000,stroke:#0f0\n  classDef blue_node fill:#ddf,color:#000,stroke:#00f\n\n  red[Red: Break the code]:::red_node\n  green[Green: Fix the code]:::green_node\n  blue[Blue: Refactor]:::blue_node\n\n  red --&gt; green --&gt; blue --&gt; red</code></pre> <p>This book follows these cycles, by first showing the test(s), then their fixes.</p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#222-first-test-create_app-should-not-crash","title":"2.2.2.  First test: <code>create_app</code> should not crash","text":"<p>Our first test is about creating a computer program that uses the Bevy game library. The Bevy class for this, is called <code>App</code>. Hence, we call the function to create a Bevy program <code>create_app</code>.</p> <p>Our first trivial test will be if <code>create_app</code> does something, i.e. it does not crash:</p> <pre><code>#[test]\nfn test_can_create_app() {\n    create_app();\n}\n</code></pre> <p>The test is the line <code>create_app();</code>, the rest is scaffolding:</p> <ul> <li><code>#[test]</code> indicates that the next function must be run when running all tests</li> <li><code>fn test_can_create_app() {</code> and <code>}</code> indicate the name, start and end of   a function called <code>test_can_create_app</code></li> <li><code>create_app();</code> calls a function called <code>create_app</code>.</li> </ul> <p>This test will break the code, as the function <code>create_app</code> does not exist yet, so the Rust compiler will give an error message. This allows us to make our dreams come true and write that <code>create_app</code> function!</p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#223-first-fix","title":"2.2.3.   First fix","text":"<p>Here is a possible implementation of <code>create_app</code>:</p> <pre><code>pub fn create_app() -&gt; App {\n    App::new()\n}\n</code></pre> <p>All it does is create a new Bevy <code>App</code> and return it. This will pass our test!</p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#224-types-of-implementations","title":"2.2.4. Types of implementations","text":"<p>The implementation of <code>create_app</code> shown above is a complete implementation: it does what it is expected to do completely. However, there are other implementations possible:</p> <ul> <li>implementations that do not follow the recommended Rust style</li> <li>implementations that are stubs</li> </ul> <p>Here is an implementation that does not follow the recommended Rust style:</p> <pre><code>pub fn create_app() -&gt; App {\n    return App::new();\n}\n</code></pre> <p>Following a consistent coding style improves software quality <code>[Fang, 2001]</code>. All code shown in this book is tested to follow the Rust style recommended by the <code>clippy</code> crate.</p> <p>Here is an implementation that is a stub:</p> <pre><code>pub fn create_app() -&gt; () {}\n</code></pre> <p>In software development, a 'stub' is 'a start of something'. The purpose of a stub is to, for example, start the architectural setup. This stub will pass all tests and hence is acceptable too. If one chooses to write a stub like this, one will need to write an addition test, that, for example, checks if the return value of <code>create_app</code> is indeed of type <code>App</code>.</p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#225-mainrs","title":"2.2.5. <code>main.rs</code>","text":"<p>The <code>main</code> function will not be used in automated testing, as it starts our game. This is useful to play the game, but not for testing. For testing to be done automatically, it is required that there is no user input. Starting the game will require at least that a user needs to do something to close it. Hence, the <code>main</code> function is useless for testing.</p> <p>Instead, the <code>main</code> function 'just' runs the <code>App</code>.</p> <pre><code>fn main() {\n    let mut app = create_app();\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p>The <code>main</code> function, however, does something our tests do not do: it adds the Bevy default plugins. These plugins will add functionality to an <code>App</code>, such as creating a window to display the program, which can be closed by, among others, pressing <code>ALT + F4</code>. Thanks to this plugin, we can see our <code>App</code>! Our game -a game that does nothing- is hence properly displayed as such:</p> <p></p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#226-code-coverage","title":"2.2.6. Code coverage","text":"<p>The code coverage of a software project is the percentage of code that has been used at least once by tests. Code coverage correlates with code quality <code>[Horgan et al., 1994]</code> <code>[Del Frate et al., 1995]</code> and some communities have a mandatory 100% code coverage to pass a code peer-review <code>[Hart et al., 2013][Ram, 2013]</code>.</p> <p>When doing TDD well, reaching a high code coverage happens almost automatically, as tests are written before any new functionality, hence that new functionality is nearly guaranteed to be tested.</p> <p>However, one needs to decide upon what to test for code coverage. Already in this simple project, we have two functions: <code>main</code> and <code>create_app</code>. Will we measure code coverage in both?</p> <p>The <code>create_app</code> function is a good candidate to be tested for code coverage, as it can be tested automatically.</p> <p>The <code>main</code> function is a bad candidate to be tested for code coverage, as it cannot be tested automatically. Instead, when <code>main</code> is called, the game is started, which requires user input, for example, pressing <code>ALT + F4</code>, to close it.</p> <p>Although the <code>main</code> function is a bad candidate, one can test it if one really wants to! For example, by writing a script that simulates input, such as sending the standard key combination <code>ALT + F4</code> to the program to close it. However, one needs to decide on a per-project basis if this extra testing is worth the extra effort.</p> <p>In this book, it is decided to test all code, except for the <code>main</code> function, as writing scripts to simulate user input is judged to be not worth the effort: the programs shown are judged to be not critical enough (read 'critical' as 'people will die if the window does not close with <code>ALT + F4</code>'). You will see that excluding the <code>main</code> function from being tested for code coverage is not a big problem: the <code>main</code> functions used in this book are always short: they create an <code>App</code> and run it!</p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#227-conclusion","title":"2.2.7. Conclusion","text":"<p>We can now create an <code>App</code>. It does nothing. We do have tested everything (i.e. nothing) it does!</p> <p>The full program can be found at https://github.com/richelbilderbeek/bevy_tdd_book_hello_world.</p>","tags":["chapter","hello","world"]},{"location":"chapters/hello_world/#228-references","title":"2.2.8. References","text":"<ul> <li><code>[Alkaoud &amp; Walcott, 2018]</code> Alkaoud, Hessah, and Kristen R. Walcott. \"Quality metrics of test suites in test-driven designed applications.\" International Journal of Software Engineering Applications (IJSEA) 2018 (2018).</li> <li><code>[Del Frate et al., 1995]</code> Del Frate, Fabio, et al. \"On the correlation between code coverage and software reliability.\" Proceedings of Sixth International Symposium on Software Reliability Engineering. ISSRE'95. IEEE, 1995.</li> <li><code>[Fang, 2001]</code> Fang, Xuefen. \"Using a coding standard to improve program quality.\" Proceedings Second Asia-Pacific Conference on Quality Software. IEEE, 2001.</li> <li><code>[Hart et al., 2013]</code> Hart, Edmumd, et al.   \"rOpenSci-a collaborative effort to develop R-based tools for facilitating   Open Science.\" figshare (2013): 791569.</li> <li><code>[Horgan et al., 1994]</code> Horgan, Joseph R., Saul London, and Michael R. Lyu. \"Achieving software quality with testing coverage measures.\" Computer 27.9 (1994): 60-69.</li> <li><code>[Janzen &amp; Saiedian, 2006]</code> Janzen, David S., and Hossein Saiedian. \"Test-driven learning: intrinsic integration of testing into the CS/SE curriculum.\" Acm Sigcse Bulletin 38.1 (2006): 254-258.</li> <li><code>[Ram, 2013]</code> Ram, K. \"rOpenSci-open tools for open science.\" AGU Fall Meeting Abstracts. Vol. 2013. 2013.</li> </ul>","tags":["chapter","hello","world"]},{"location":"chapters/move_camera/","title":"Move a camera","text":"<p>This chapter shows how to move a camera.</p> <p>The idea is to give a camera a velocity, making the camera move on screen.</p> <p>This chapter introduces nothing new.</p>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#first-test-our-app-needs-a-camera-velocity","title":"First test: our <code>App</code> needs a camera velocity","text":"<pre><code>fn test_can_create_app_with_a_velocity() {\n    let velocity = Vec2::new(0.2, 0.1);\n    create_app(velocity);\n}\n</code></pre>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#second-test-an-empty-app-has-no-camera","title":"Second test: an empty <code>App</code> has no camera","text":"<pre><code>fn test_empty_app_has_no_moving_cameras() {\n    let mut app = App::new();\n    app.update();\n    assert_eq!(count_n_moving_cameras(&amp;mut app), 0);\n}\n</code></pre>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#third-test-our-app-has-a-camera","title":"Third test: our <code>App</code> has a camera","text":"<pre><code>fn test_create_app_has_a_moving_camera() {\n    let velocity = Vec2::new(0.0, 0.0);\n    let mut app = create_app(velocity);\n    app.update();\n    assert_eq!(count_n_moving_cameras(&amp;mut app), 1);\n}\n</code></pre>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#fourth-test-camera-starts-at-origin","title":"Fourth test: camera starts at origin","text":"<pre><code>fn test_camera_starts_at_origin() {\n    let velocity = Vec2::new(0.0, 0.0);\n    let mut app = create_app(velocity);\n    app.update();\n    assert_eq!(get_camera_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#fifth-test-camera-moves","title":"Fifth test: camera moves","text":"<pre><code>fn test_moving_camera_moves() {\n    let velocity = Vec2::new(1.2, 3.4);\n    let mut app = create_app(velocity);\n    app.update();\n    assert_ne!(get_camera_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#mainrs","title":"<code>main.rs</code>","text":"<pre><code>fn main() {\n    let velocity = Vec2::new(0.2, 0.1);\n    let mut app = create_app(velocity);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with a camera that moves. When running the <code>App</code>, we can see the camera moves. We have tested everything that the App does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_move_camera.</p>","tags":["chapter","move","camera"]},{"location":"chapters/move_camera_with_keyboard/","title":"Move a camera with a keyboard","text":"<p>This chapter shows how to move a camera with a keyboard.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to change the camera's position, rotation and zoom upon a key press.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#first-test-an-empty-app-has-no-cameras","title":"First test: an empty <code>App</code> has no cameras","text":"<pre><code>fn test_empty_app_has_no_cameras() {\n    let mut app = App::new();\n    assert_eq!(count_n_cameras(&amp;mut app), 0);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#second-test-our-app-has-one-camera","title":"Second test: our <code>App</code> has one camera","text":"<pre><code>fn test_create_app_has_a_moving_camera() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_cameras(&amp;mut app), 1);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#third-test-our-player-is-at-the-origin","title":"Third test: our player is at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#fourth-test-our-player-has-a-proper-size","title":"Fourth test: our player has a proper size","text":"<pre><code>fn test_player_has_a_custom_size() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_size(&amp;mut app), Vec2::new(64.0, 32.0));\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#fifth-test-our-camera-starts-at-the-origin","title":"Fifth test: our camera starts at the origin","text":"<pre><code>fn test_camera_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#sixth-test-our-camera-moves-when-pressing-the-arrow-up-key","title":"Sixth test: our camera moves when pressing the arrow up key","text":"<pre><code>fn test_camera_moves_when_pressed_up() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n    // Press the key\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;KeyCode&gt;&gt;()\n        .press(KeyCode::ArrowUp);\n    app.update();\n    assert_ne!(get_camera_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#seventh-test-our-camera-is-not-rotated-at-the-start","title":"Seventh test: our camera is not rotated at the start","text":"<pre><code>fn test_camera_is_not_rotated_at_start() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_rotation(&amp;mut app), 0.0);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#eighth-test-our-camera-rotates-when-pressing-the-q-key","title":"Eighth test: our camera rotates when pressing the Q key","text":"<pre><code>fn test_camera_rotates_when_pressed_q() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_rotation(&amp;mut app), 0.0);\n\n    // Press the key\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;KeyCode&gt;&gt;()\n        .press(KeyCode::KeyQ);\n    app.update();\n\n    assert_ne!(get_camera_rotation(&amp;mut app), 0.0);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#ninth-test-our-camera-is-not-zoomed-in-or-out-at-the-start","title":"Ninth test: our camera is not zoomed in or out at the start","text":"<pre><code>fn test_camera_is_not_zoomed_in_or_out_at_start() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_zoom(&amp;mut app), 1.0);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#tenth-test-our-camera-zooms-in-when-pressing-the-w-key","title":"Tenth test: our camera zooms in when pressing the W key","text":"<pre><code>fn test_camera_zooms_in_when_pressed_w() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_zoom(&amp;mut app), 1.0);\n\n    // Press the key\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;KeyCode&gt;&gt;()\n        .press(KeyCode::KeyW);\n    app.update();\n\n    assert!(get_camera_zoom(&amp;mut app) &lt; 1.0);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#eleventh-test-our-camera-zooms-out-when-pressing-the-s-key","title":"Eleventh test: our camera zooms out when pressing the S key","text":"<pre><code>fn test_camera_zoom_out_when_pressed_s() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_camera_zoom(&amp;mut app), 1.0);\n\n    // Press the key\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;KeyCode&gt;&gt;()\n        .press(KeyCode::KeyS);\n    app.update();\n\n    assert!(get_camera_zoom(&amp;mut app) &gt; 1.0);\n}\n</code></pre>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#mainrs","title":"<code>main.rs</code>","text":"<p>Running the application shows the camera movement in action.</p> <p></p>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_keyboard/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with a camera that responds to key presses. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_move_camera_with_keyboard.</p>","tags":["chapter","move","camera","keyboard"]},{"location":"chapters/move_camera_with_mouse/","title":"Move a camera with a mouse","text":"<p>This chapter shows how to move a camera with a mouse.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to change the camera's position, rotation and zoom upon mouse input.</p> <p>These tests are the same as in the minimal examples.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["chapter","move","camera","mouse"]},{"location":"chapters/move_camera_with_mouse/#mainrs","title":"<code>main.rs</code>","text":"<pre><code>fn main() {\n    let mut app = create_app();\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p>Running the application shows the camera movement in action.</p> <p></p>","tags":["chapter","move","camera","mouse"]},{"location":"chapters/move_camera_with_mouse/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with a camera that responds to key presses. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_move_camera_with_mouse.</p>","tags":["chapter","move","camera","mouse"]},{"location":"chapters/move_player/","title":"2.8. Move a player","text":"<p>This chapter shows how to move a player.</p> <p></p> <p>The idea is to give a player a velocity, making the player move on screen.</p> <p>This chapter introduces:</p> <ul> <li>how to extend our own Bevy component</li> <li>adding an <code>Update</code> system</li> </ul>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#281-first-test-an-empty-app-has-no-players","title":"2.8.1.  First test: an empty <code>App</code> has no players","text":"<p>Similar to all earlier chapters, we open our test suite with counting the number of players in an empty <code>App</code>:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#282-first-fix","title":"2.8.2.  First fix","text":"<p>We have done this before, in the <code>add_player</code> chapter. If you've forgot, look up the implementation there and come back here.</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#283-second-test-our-app-stores-an-initial-velocity","title":"2.8.3.  Second test: our <code>App</code> stores an initial velocity","text":"<p>The idea of this app is to give the player a velocity, so that we can see it move.</p> <p>Here we shorten two TDD tests into one (to save book pages, not because it is good practice):</p> <pre><code>fn test_can_set_and_get_velocity() {\n    let velocity = Vec2::new(1.2, 3.4);\n    let mut app = create_app(velocity);\n    app.update();\n    assert_eq!(get_player_velocity(&amp;mut app), velocity);\n}\n</code></pre> <p>The two tests are:</p> <ul> <li><code>create_app</code> must be a function that takes a velocity as an input argument</li> <li><code>get_player_velocity</code> returns the velocity from a game</li> </ul> <p>Note that we pick a <code>Vec2</code> as the data type to store a velocity. Bevy uses <code>Vec2</code> and <code>Vec3</code> extensively, among other for coordinates, hence here I extend that practice. This is just a social convention, so feel free to create your own velocity structure if you feel like it!</p> <p>Again, shortening the amount of tests is done here to save book pages, not because it is good practice: it forces me to go quicker (and not write about intermediate stubs).</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#284-second-fix","title":"2.8.4.  Second fix","text":"<p>To fix this, we'll need to:</p> <ul> <li>write a <code>Player</code> <code>Component</code> that can hold a velocity</li> <li><code>create_app</code> must accept a velocity and add a <code>Player</code> component   with that velocity to the world</li> <li><code>get_player_velocity</code> must extract the velocity from our <code>Player</code> component</li> </ul> <p>Writing a <code>Player</code> <code>Component</code> that can hold a velocity is hard as extending any Rust structure:</p> <pre><code>#[derive(Component)]\npub struct Player {\n    pub velocity: Vec2,\n}\n</code></pre> <p>Because the game is 2D, the velocity is also in two dimensions.</p> <p>Our <code>create_app</code> must accept a velocity and add a <code>Player</code> component with that velocity to the world:</p> <pre><code>pub fn create_app(velocity: Vec2) -&gt; App {\n    let mut app = App::new();\n    app.add_systems(Startup, move |commands: Commands| {\n        add_player(commands, velocity);\n    });\n    app\n}\n</code></pre> <p>Similar to earlier chapters, a closure is used to allow the <code>add_player</code> function with two function arguments to fit in a system that uses only one. We could have used a local closure too, but the <code>add_player</code> function feels too long to fit in, as shown below.</p> <p>Here is the <code>add_player</code> function:</p> <pre><code>fn add_player(mut commands: Commands, velocity: Vec2) {\n    commands.spawn((\n        Sprite {\n            transform: Transform {\n                scale: Vec3::new(64.0, 32.0, 0.0),\n                ..default()\n            },\n            ..default()\n        },\n        Player { velocity },\n    ));\n}\n</code></pre> <p>The <code>add_player</code> function adds a <code>Sprite</code> with a <code>Player</code> component, as we've done earlier. New is that we now initialize the <code>Player</code> component too. You may have expected to see <code>velocity: velocity</code> as a syntax, but, no, this is the proper Rust syntax (and if you disagree, <code>clippy</code> will remind you) :-) .</p> <p>The <code>get_player_velocity</code> that extracts the velocity from our <code>Player</code> component can be implemented in the familiar fashion as shown here:</p> <pre><code>fn get_player_velocity(app: &amp;mut App) -&gt; Vec2 {\n    let mut query = app.world_mut().query::&lt;&amp;Player&gt;();\n    let player = query.single(app.world());\n    player.velocity\n}\n</code></pre> <p>We can directly query for a <code>Player</code> component, as we can be sure other Bevy plugins will not add more <code>Player</code> components: those Bevy plugins have no idea our <code>Player</code> structure exists, nor do they feel the need to add one. This is a different from when using a <code>Transform</code>, which is used by multiple default Bevy plugins.</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#285-third-test-our-app-has-a-player","title":"2.8.5.  Third test: our <code>App</code> has a player","text":"<p>We've been counting the number of players since the <code>add_player</code> chapter:</p> <pre><code>fn test_create_app_has_a_player() {\n    let velocity = Vec2::new(0.0, 0.0);\n    let mut app = create_app(velocity);\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre> <p>See the <code>add_player</code> chapter for its implementation.</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#286-fourth-test-the-player-starts-at-the-origin","title":"2.8.6.  Fourth test: the player starts at the origin","text":"<p>Without other information, we expect a player to be created at the origin (i.e. position <code>(0.0, 0.0)</code>). And when such a player has no velocity (i.e. a speed of zero in both dimensions), it's position should remain at the origin. We use this test as a prelude for the next, where we will test that the player is actually moving.</p> <p>With this context added, the test is familiar, as we've been getting the position of the player at the <code>add_player_sprite</code> chapter:</p> <pre><code>fn test_player_starts_at_the_origin() {\n    let velocity = Vec2::new(0.0, 0.0);\n    let mut app = create_app(velocity);\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre> <p>See the <code>add_player_sprite</code> chapter for its implementation.</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#287-fifth-test-a-player-moves","title":"2.8.7.  Fifth test: a player moves","text":"<p>Now we have all the pieces in place to test for movement:</p> <pre><code>fn test_player_moves() {\n    let velocity = Vec2::new(1.2, 3.4);\n    let mut app = create_app(velocity);\n    app.update(); // moves the player\n    assert_ne!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre> <p>The test is generous, as it only checks that the player changes position. Instead, it could have tested that the position of the player would be, say, at <code>(1.2, 3.4)</code>. Such a specific test would be fragile, as adding forces such as friction and/or gravity would cause the test to break. The test shown here is enough to force us to add player movement, hence we'll stick with it. If we need precise movement tests, sure, go ahead and add these!</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#288-fifth-fix","title":"2.8.8.  Fifth fix","text":"<p>Making a player move is a (Bevy) system: it is a -typically- function that works on entities in the world. Unlike other earlier systems, moving a player needs to be done every frame (instead of only at startup). To specify this, use the <code>Update</code> <code>ScheduleLabel</code>:</p> <pre><code>pub fn create_app(velocity: Vec2) -&gt; App {\n    // ...\n    app.add_systems(Update, move_player);\n    // ...\n}\n</code></pre> <p>The word 'Update' is the name of our second schedule, i.e. it indicates when the system should be run. In our case, the system should be run when updating the screen.</p> <p>The <code>move_player</code> function 'magically' has a <code>Query</code> as a function argument:</p> <pre><code>fn move_player(mut query: Query&lt;(&amp;mut Transform, &amp;Player)&gt;) {\n    let (mut player_sprite, player) = query.single_mut();\n    player_sprite.translation.x += player.velocity.x;\n    player_sprite.translation.y += player.velocity.y;\n}\n</code></pre> <p>That function argument is the most interesting of the function: <code>query</code> will contain all <code>Transforms</code> marked with a <code>Player</code>, where -for the first time!- we can modify the <code>Transform</code>.</p> <p>These 'magic' function arguments are not magic at all when reading the Bevy documentation. Especially, the Unofficial Bevy Cheat Book (at https://bevy-cheatbook.github.io) nicely document all these 'magic' options:</p> <p></p> <p>Part of the Unofficial Bevy Cheat Book 'SystemParams' documentation</p> <p>These options are available to all Bevy systems. To repeat, a Bevy system is a function that works on a Bevy World. And <code>move_player</code> indeed is a Bevy system, that modifies the <code>Player</code> in our Bevy <code>World</code>.</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#289-mainrs","title":"2.8.9. <code>main.rs</code>","text":"<p>To see that it works, this is the code we can use:</p> <pre><code>fn main() {\n    let velocity = Vec2::new(0.2, 0.1);\n    let mut app = create_app(velocity);\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p>This, by now, is quite familiar code, most similar to the 'Add a player sprite' chapter. See that chapter for a refresher.</p> <p>Running this code, we can indeed see our player move:</p> <p></p>","tags":["chapter","move","player"]},{"location":"chapters/move_player/#2810-conclusion","title":"2.8.10. Conclusion","text":"<p>We can now create an <code>App</code> with one player sprite that moves. When running the <code>App</code>, we can see the player moves. We have tested everything that the App does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_move_player.</p>","tags":["chapter","move","player"]},{"location":"chapters/move_player_with_keyboard/","title":"Move a player with a keyboard","text":"<p>This chapter shows how to move a player with a keyboard.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to give a player a velocity upon a key press.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["move","player","keyboard"]},{"location":"chapters/move_player_with_keyboard/#mainrs","title":"<code>main.rs</code>","text":"<pre><code>fn main() {\n    let mut app = create_app();\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n\n    assert!(!app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.add_plugins(DefaultPlugins);\n\n    app.run();\n}\n</code></pre>","tags":["move","player","keyboard"]},{"location":"chapters/move_player_with_keyboard/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with one player sprite that responds to key presses. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_move_player_with_keyboard.</p>","tags":["move","player","keyboard"]},{"location":"chapters/move_player_with_mouse/","title":"Move a camera with a keyboard","text":"<p>This chapter shows how to move a camera with a keyboard.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to change the camera's position, rotation and zoom upon a key press.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#first-test-an-empty-app-has-no-players","title":"First test: an empty <code>App</code> has no players","text":"<pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#second-test-our-app-has-a-players","title":"Second test: our <code>App</code> has a players","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#third-test-the-player-starts-at-the-origin","title":"Third test: the player starts at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#fourth-test-the-player-moves-position-when-mouse-moves","title":"Fourth test: the player moves position when mouse moves","text":"<pre><code>fn test_player_responds_to_mouse_move() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n    // Move the mouse\n    app.world_mut().send_event(bevy::input::mouse::MouseMotion {\n        delta: Vec2::new(100.0, 100.0),\n    });\n\n    app.update();\n    assert_ne!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#fifth-test-the-player-is-not-rotated-at-the-start","title":"Fifth test: the player is not rotated at the start","text":"<pre><code>fn test_player_is_not_rotated_at_start() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_rotation(&amp;mut app), 0.0);\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#six-test-pressing-a-mouse-button-rotates-the-player","title":"Six test: pressing a mouse button rotates the player","text":"<pre><code>fn test_player_responds_to_left_mouse_button_press() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;bevy::input::InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(get_player_rotation(&amp;mut app), 0.0);\n\n    // Press the left mouse button\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;MouseButton&gt;&gt;()\n        .press(MouseButton::Left);\n\n    app.update();\n\n    // Position must have changed now\n    assert_ne!(get_player_rotation(&amp;mut app), 0.0);\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#seventh-test-the-player-has-an-initial-size","title":"Seventh test: the player has an initial size","text":"<pre><code>fn test_player_has_a_custom_size() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_size(&amp;mut app), Vec2::new(64.0, 32.0));\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#eight-test-the-player-changes-size-when-the-mousewheel-is-turned","title":"Eight test: the player changes size when the mousewheel is turned","text":"<pre><code>fn test_player_responds_to_mouse_wheel_turn() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;bevy::input::InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(get_player_size(&amp;mut app), Vec2::new(64.0, 32.0));\n\n    // Scroll the mouse\n    app.world_mut().send_event(bevy::input::mouse::MouseWheel {\n        unit: bevy::input::mouse::MouseScrollUnit::Line,\n        x: 10.0,\n        y: 10.0,\n        window: Entity::PLACEHOLDER,\n    });\n    app.update();\n\n    // Moved now\n    assert_ne!(get_player_size(&amp;mut app), Vec2::new(64.0, 32.0));\n}\n</code></pre>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#mainrs","title":"<code>main.rs</code>","text":"<pre><code>fn main() {\n    let mut app = create_app();\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app.add_plugins(DefaultPlugins);\n\n    app.run();\n}\n</code></pre> <p>Running the application shows the player movement in action.</p> <p></p>","tags":["move","camera","keyboard"]},{"location":"chapters/move_player_with_mouse/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with a camera that responds to key presses. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_move_player_with_mouse.</p>","tags":["move","camera","keyboard"]},{"location":"chapters/respond_to_just_key_pressed/","title":"Respond to a key just being pressed","text":"<p>This chapter shows how to respond to a key that is just being pressed on a keyboard.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something upon a key just being pressed.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_just_key_pressed/#first-test-an-empty-app-has-no-players","title":"First test: an empty <code>App</code> has no players","text":"<pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_just_key_pressed/#second-test-an-app-has-a-player","title":"Second test: an <code>App</code> has a player","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_just_key_pressed/#fourth-test-an-app-has-a-player-placed-at-the-origin","title":"Fourth test: an <code>App</code> has a player placed at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_just_key_pressed/#fifth-test-pressing-spacebar-moves-the-player","title":"Fifth test: pressing spacebar moves the player","text":"<pre><code>#[test]\nfn test_player_responds_to_just_key_press() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n    // Press the Enter button, thanks kristoff3r\n    app.world_mut()\n        .send_event(bevy::input::keyboard::KeyboardInput {\n            key_code: KeyCode::Space,\n            logical_key: Key::Space,\n            state: bevy::input::ButtonState::Pressed,\n            window: Entity::PLACEHOLDER,\n        });\n\n    app.update();\n\n    // Moved now\n    assert_ne!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_just_key_pressed/#mainrs","title":"<code>main.rs</code>","text":"","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_just_key_pressed/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to a key press. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_just_key_pressed.</p>","tags":["respond","key","press","just"]},{"location":"chapters/respond_to_key_press/","title":"Respond to a key press","text":"<p>This chapter shows how to respond to a key press as done on a keyboard.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something upon a key press.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","key","press"]},{"location":"chapters/respond_to_key_press/#second-test-an-empty-app-has-no-players","title":"Second test: an empty <code>App</code> has no players","text":"<pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","key","press"]},{"location":"chapters/respond_to_key_press/#third-test-an-app-has-a-player","title":"Third test: an <code>App</code> has a player","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","key","press"]},{"location":"chapters/respond_to_key_press/#fourth-test-an-app-has-a-player-placed-at-the-origin","title":"Fourth test: an <code>App</code> has a player placed at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","key","press"]},{"location":"chapters/respond_to_key_press/#fifth-test-pressing-spacebar-moves-the-player","title":"Fifth test: pressing spacebar moves the player","text":"<pre><code>fn test_player_responds_to_key_press() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n    // Press the right arrow button, thanks Periwinkle\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;KeyCode&gt;&gt;()\n        .press(KeyCode::Space);\n\n    app.update();\n\n    // Position must have changed now\n    assert_ne!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","key","press"]},{"location":"chapters/respond_to_key_press/#mainrs","title":"<code>main.rs</code>","text":"<pre><code>fn main() {\n    let mut app = create_app();\n    let add_camera_fn = |mut commands: Commands| {\n        commands.spawn(Camera2d);\n    };\n    app.add_systems(Startup, add_camera_fn);\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre>","tags":["respond","key","press"]},{"location":"chapters/respond_to_key_press/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to a key press. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_key_press.</p>","tags":["respond","key","press"]},{"location":"chapters/respond_to_mouse_button_press/","title":"Respond to a mouse button press","text":"<p>This chapter shows how to respond to a mouse button press.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something upon a mouse button press.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","mouse button","press"]},{"location":"chapters/respond_to_mouse_button_press/#first-test-an-emty-app-has-no-players","title":"First test: an emty <code>App</code> has no players","text":"<p>Forces us to write <code>count_n_players</code>.</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","mouse button","press"]},{"location":"chapters/respond_to_mouse_button_press/#second-test-our-app-has-a-player","title":"Second test: our <code>App</code> has a player","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","mouse button","press"]},{"location":"chapters/respond_to_mouse_button_press/#third-test-player-is-at-the-origin","title":"Third test: player is at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","mouse button","press"]},{"location":"chapters/respond_to_mouse_button_press/#fourth-test-player-position-changes-upon-mouse-button-press","title":"Fourth test: player position changes upon mouse button press","text":"<pre><code>fn test_player_responds_to_mouse_button_press() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(Vec2::new(0.0, 0.0), get_player_position(&amp;mut app));\n\n    // Press the left mouse button\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;MouseButton&gt;&gt;()\n        .press(MouseButton::Left);\n\n    app.update();\n\n    // Position must have changed now\n    assert_ne!(Vec2::new(0.0, 0.0), get_player_position(&amp;mut app));\n}\n</code></pre>","tags":["respond","mouse button","press"]},{"location":"chapters/respond_to_mouse_button_press/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to mouse button press. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_mouse_button_press.</p>","tags":["respond","mouse button","press"]},{"location":"chapters/respond_to_mouse_move/","title":"Respond to a mouse move","text":"<p>This chapter shows how to respond to a mouse move.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something upon a mouse move.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","mouse","move"]},{"location":"chapters/respond_to_mouse_move/#first-test-an-empty-app-has-no-players","title":"First test: an empty <code>App</code> has no players","text":"<p>Forces us to write <code>count_n_players</code>.</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","mouse","move"]},{"location":"chapters/respond_to_mouse_move/#second-test-our-app-has-a-player","title":"Second test: our <code>App</code> has a player","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","mouse","move"]},{"location":"chapters/respond_to_mouse_move/#third-test-player-is-at-the-origin","title":"Third test: player is at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","mouse","move"]},{"location":"chapters/respond_to_mouse_move/#fifth-test-player-position-changes-upon-mouse-move","title":"Fifth test: player position changes upon mouse move","text":"<pre><code>fn test_player_responds_to_mouse_move() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n    // Move the mouse\n    app.world_mut().send_event(bevy::input::mouse::MouseMotion {\n        delta: Vec2::new(100.0, 100.0),\n    });\n\n    app.update();\n\n    // Position must have changed now\n    assert_ne!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre> <p>Resulting in:</p> <pre><code>pub fn create_app() -&gt; App {\n    let mut app = App::new();\n\n    // Only add this plugin in testing.\n    // The main app will assume it to be absent\n    if cfg!(test) {\n        app.add_plugins(InputPlugin);\n    }\n\n    app.add_systems(Startup, add_player);\n    app.add_systems(Update, respond_to_mouse_move);\n\n    // Do not do update, as this will disallow to do more steps\n    // app.update(); //Don't!\n    app\n}\n\nfn respond_to_mouse_move(\n    mut query: Query&lt;&amp;mut Transform, With&lt;Player&gt;&gt;,\n    mut mouse_motion_event: EventReader&lt;MouseMotion&gt;,\n) {\n    for event in mouse_motion_event.read() {\n        let mut player_position = query.single_mut();\n        player_position.translation.x += event.delta.x / 20.0;\n        player_position.translation.y -= event.delta.y / 20.0;\n    }\n}\n</code></pre>","tags":["respond","mouse","move"]},{"location":"chapters/respond_to_mouse_move/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to mouse movement. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_mouse_move.</p>","tags":["respond","mouse","move"]},{"location":"chapters/respond_to_mouse_wheel_press/","title":"Respond to a mouse wheel press","text":"<p>This chapter shows how to respond to a mouse wheel press.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something upon a mouse wheel press.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","mouse wheel","press"]},{"location":"chapters/respond_to_mouse_wheel_press/#first-test-an-empty-app-has-no-players","title":"First test: an empty <code>App</code> has no players","text":"<p>Forces us to write <code>count_n_players</code>.</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","mouse wheel","press"]},{"location":"chapters/respond_to_mouse_wheel_press/#second-test-our-app-has-a-player","title":"Second test: our <code>App</code> has a player","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","mouse wheel","press"]},{"location":"chapters/respond_to_mouse_wheel_press/#third-test-player-is-at-the-origin","title":"Third test: player is at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","mouse wheel","press"]},{"location":"chapters/respond_to_mouse_wheel_press/#fourth-test-player-position-changes-upon-mouse-wheel-turn","title":"Fourth test: player position changes upon mouse wheel turn","text":"<pre><code>fn test_player_responds_to_mouse_wheel_press() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n\n    // Press the left mouse button\n    app.world_mut()\n        .resource_mut::&lt;ButtonInput&lt;MouseButton&gt;&gt;()\n        .press(MouseButton::Middle);\n\n    app.update();\n\n    // Position must have changed now\n    assert_ne!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","mouse wheel","press"]},{"location":"chapters/respond_to_mouse_wheel_press/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to a mouse wheel press. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_mouse_wheel_press.</p>","tags":["respond","mouse wheel","press"]},{"location":"chapters/respond_to_mouse_wheel_turn/","title":"Respond to a mouse wheel turn","text":"<p>This chapter shows how to respond to a mouse wheel turn.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something upon a mouse wheel turn.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_mouse_wheel_turn/#first-test-create-an-app","title":"First test: create an <code>App</code>","text":"<p>A trivial test, to get us to write <code>create_app</code>:</p> <pre><code>#[test]\nfn test_can_create_app() {\n    create_app();\n}\n</code></pre>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_mouse_wheel_turn/#second-test-no-players-at-the-start","title":"Second test: no players at the start","text":"<p>Forces us to write <code>count_n_players</code>.</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_mouse_wheel_turn/#third-test-add-a-player","title":"Third test: add a player","text":"<pre><code>fn test_create_app_has_a_player() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_players(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_mouse_wheel_turn/#fourth-test-player-is-at-the-origin","title":"Fourth test: player is at the origin","text":"<pre><code>fn test_player_is_at_origin() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_player_position(&amp;mut app), Vec2::new(0.0, 0.0));\n}\n</code></pre>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_mouse_wheel_turn/#fifth-test-player-position-changes-upon-mouse-wheel-turn","title":"Fifth test: player position changes upon mouse wheel turn","text":"<pre><code>fn test_player_responds_to_mouse_wheel_turn() {\n    let mut app = create_app();\n    assert!(app.is_plugin_added::&lt;InputPlugin&gt;());\n    app.update();\n\n    // Not moved yet\n    assert_eq!(Vec2::new(0.0, 0.0), get_player_position(&amp;mut app));\n\n    // Scroll the mouse\n    app.world_mut().send_event(bevy::input::mouse::MouseWheel {\n        unit: bevy::input::mouse::MouseScrollUnit::Line,\n        x: 10.0,\n        y: 10.0,\n        window: Entity::PLACEHOLDER,\n    });\n    app.update();\n\n    // Moved now\n    assert_ne!(Vec2::new(0.0, 0.0), get_player_position(&amp;mut app));\n}\n</code></pre>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_mouse_wheel_turn/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to a mouse wheel turn. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_mouse_wheel_turn.</p>","tags":["respond","mouse wheel","turn"]},{"location":"chapters/respond_to_window_resize/","title":"Respond to a window resize","text":"<p>This chapter shows how to respond to the resizing of a window.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>The idea is to do something when a window resizes.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#first-test-create-an-app","title":"First test: create an <code>App</code>","text":"<p>A trivial test, to get us to write <code>create_app</code>:</p> <pre><code>fn test_can_create_app() {\n    create_app();\n}\n</code></pre>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#second-test-an-empty-app-has-no-texts","title":"Second test: an empty <code>App</code> has no texts","text":"<p>To force us to write <code>count_n_texts</code>. The word <code>text</code> is shorthand for 'the <code>Text</code> <code>Component</code> of a <code>Text2d</code>'.</p> <pre><code>fn test_empty_app_has_no_texts() {\n    let mut app = App::new();\n    assert_eq!(count_n_texts(&amp;mut app), 0);\n}\n</code></pre>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#third-test-our-app-has-a-text","title":"Third test: our <code>App</code> has a text","text":"<p>Forces us to add a <code>Text2d</code>:</p> <pre><code>fn test_create_app_has_a_text() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(count_n_texts(&amp;mut app), 1);\n}\n</code></pre>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#fourth-test-the-text-in-our-app-is-empty-at-the-start","title":"Fourth test: the text in our <code>App</code> is empty at the start","text":"<p>Forces us to write <code>get_text_text</code>:</p> <pre><code>fn test_text_at_start_is_empty() {\n    let mut app = create_app();\n    app.update();\n    assert_eq!(get_text_text(&amp;mut app), \"\");\n}\n</code></pre>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#fifth-test-the-text-in-our-app-changes-upon-a-window-resize","title":"Fifth test: the text in our <code>App</code> changes upon a window resize","text":"<p>Forces us to change the text upon a window resize:</p> <pre><code>fn test_respond_to_window_resize() {\n    let mut app = create_app();\n    app.update();\n\n    //Resize the window\n    app.world_mut().send_event(bevy::window::WindowResized {\n        window: Entity::PLACEHOLDER,\n        width: 100.0,\n        height: 100.0,\n    });\n    app.update();\n\n    assert_ne!(get_text_text(&amp;mut app), \"\");\n}\n</code></pre> <p>Results in:</p> <pre><code>fn respond_to_window_resize(\n    mut q: Query&lt;&amp;mut Text2d&gt;,\n    mut resize_reader: EventReader&lt;bevy::window::WindowResized&gt;,\n) {\n    let mut text = q.single_mut();\n    for e in resize_reader.read() {\n        text.0 = format!(\"{:.1} x {:.1}\", e.width, e.height);\n    }\n}\n</code></pre> <p>and:</p> <pre><code>pub fn create_app() -&gt; App {\n    let mut app = App::new();\n\n    // Only add this plugin in testing.\n    // The main app will assume it to be absent\n    if cfg!(test) {\n        app.add_plugins(bevy::window::WindowPlugin::default());\n    }\n\n    // ...\n    app.add_systems(Update, respond_to_window_resize);\n    app\n}\n</code></pre>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#mainrs","title":"<code>main.rs</code>","text":"<p>Running our <code>App</code>:</p> <pre><code>fn main() {\n    let mut app = create_app();\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre> <p></p>","tags":["respond","window","resize"]},{"location":"chapters/respond_to_window_resize/#conclusion","title":"Conclusion","text":"<p>We can now create an <code>App</code> with something that responds to a window resize. We have tested everything that the <code>App</code> does!</p> <p>Full code can be found at https://github.com/richelbilderbeek/bevy_tdd_book_respond_to_window_resize.</p>","tags":["respond","window","resize"]},{"location":"chapters/show_2d_coordinate_systems/","title":"Showing the 2D coordinate systems","text":"<p>This application is more of a demonstration.</p> <p>This chapter introduces:</p> <ul> <li>TODO</li> </ul> <p>To make the text nicely formatted, there are many <code>[something]_to_str</code> helper functions, such as:</p> <pre><code>fn test_coordinate_to_str() {\n    assert_eq!(\n        coordinate_to_str(Vec2::new(1.2, 3.4)),\n        String::from(\"(1.2, 3.4)\")\n    )\n}\n</code></pre> <p>and:</p> <pre><code>fn test_ucoordinate_to_str() {\n    assert_eq!(ucoordinate_to_str(UVec2::new(1, 2)), String::from(\"(1, 2)\"))\n}\n</code></pre> <p></p>","tags":["coordinate","2D","system","display","show"]},{"location":"chapters/use_game_state/","title":"Use game state","text":"<p>This page is a stub.</p> <pre><code>fn main() {\n    let mut app = create_app();\n    app.run();\n}\n</code></pre>","tags":["game state"]},{"location":"chapters/use_resources/","title":"Use resources","text":"<p>This page is a stub.</p> <pre><code>fn main() {\n    let mut app = create_default_app();\n    app.add_plugins(DefaultPlugins);\n    app.run();\n}\n</code></pre>","tags":["resources"]},{"location":"chapters/use_window_title/","title":"Use window title","text":"<p>This page is a stub.</p> <pre><code>fn main() {\n    let mut app = create_app();\n    app.run();\n}\n</code></pre>","tags":["window","title"]},{"location":"feedback/","title":"Feedback","text":"<p>Here I collect feedback about this book, to make sure all feedback is used.</p> <ul> <li>Feedback 2024-10-16 by @donedgardo</li> </ul>"},{"location":"feedback/feedback_issue_8/","title":"https://github.com/richelbilderbeek/bevy_tdd_book/issues/8","text":"<p>Feedback from @donedgardo below:</p> <p>I have had this draft for a while. The thoughts are unorganized, and haven\u2019t had the chance to finish reading the book.</p> <p>But I thought early feedback is better than late.</p> <p>Introduction:</p> <p>I believe the focus of 100 percent coverage is not a good reason for TDD. Aiming for 100 percent is an ok goal yet it is unachievable (Eg You cant have test coverage on main.)</p> <p>Edgardo has a point here: 100% code coverage is not always possible. I've changed this:</p> <p>[...] always aiming for 100% code coverage whenever possible.</p> <p>Done!</p> <p>A better reason for adopting TDD is to give developers the confidence that their changes work. As a byproduct of this newly found confidence, developers deliver value to customers at a high pace with minimal bugs. High quality product is the customers value for TDD; and high confidence, and easy of adding new features is the value to the developer.</p> <p>Pressing a button that tells you that its ok to deploy the new changes to your users confidently, this is what truly is all about.</p> <p>Edgardo has a point here: the goal of TDD is indeed not a high code coverage. I've changed the paragraph to state it way my personal goal of the book.</p> <ul> <li>[ ] Check if indeed 100% code coverage is not mentioned as a goal,   like Eduardo states here</li> </ul> <p>2.3.1 The reason app has to be mutable is because of the update method.</p> <p>Changed to:</p> <p>'The Bevy library, however, has good reasons why <code>App</code> must be mutable: also reading data need to be done in a safe way.'</p> <p>I feel mentioning the 'update' method does not help the reader</p> <p>2.3.2 Might benefit to remove the return and semicolon in the implementation to keep consistent the rustacian ways. Maybe you can take the opportunity to teach about the blue phase, refactoring, after making the test pass. I think it would be valuable to show new TDD devs what phase we are at either red, green or blue. Color coding each section to get that rhythm of fail, pass, clean up.</p> <p>I corrected the code: Eduardo is right. I wonder why clippy did not fix this, I guess because it is a test function ...</p> <p>Color-coding sections seems like a fun idea. I try it out.</p> <ul> <li>[x] Consider color-coding sections</li> </ul> <p>I've added it to two sections to see how it feels.</p> <p>2.3.4 I dont like the fact that we just wrote a test that now will fail by modifying the create app to add a player. I would create a new test that create app doesn\u2019t create a player, and another test where we test where we add the new add player system and test it does.</p> <p>An alternative is to initially test that it has a player from the start, and work toward making it pass, and refactor step to make it into its own system \u201cadd_player\u201d. A concept I think this section is missing is that when you are going from red to green you write only enough code to make the test pass.</p> <p>When some is as experienced as us doing TDD we might skip these micro steps but for someone just learning I would suggest breaking those down even further.</p> <p>Agreed, I've added more smaller tests!</p> <p>Blimey, the <code>count_n_players</code> function is not even mentioned!</p> <p>I feel that using create_app function to test individual systems will be hard to maintain our test. I suggest separating the app creation and systems under different test cases. The create app should just create the app, not very valuable tbh. The test to check if it crashes might be a better candidate for end to end test instead of an unit test. Thinking more about this I think first testing a system is more straightforward that testing the if the app crashes or not.</p> <p>For this, I simply don't know how to implement 'separating the app creation and systems'. Maybe that explains why we disagree on the usefulness of the <code>create_app</code> function. I agree with 'testing a system is more straightforward that testing the if the app crashes or not', but -again- I don't know how to create a system...</p> <p>2.4.1 As I feared, create app is doing too much and by adding a feature of adding player sprite it forces us to change a lot of signatures of test that where using create_app.</p> <p>I think the reviewer misunderstood that this chapter starts from scratch again. I've made this more clear in the chapter's text.</p> <p>An idea would be to create a empty app on each test and add the system under test, and only those systems to keep test easier to maintain. Testing create app where it adds all systems will be hard to maintain, especially when systems that depend on third party plugins</p> <p>I feel here again, I am unsure what the reviewer means by creating a system.</p> <p>2.4.3 I think it\u2019s wasteful to add a test that just passes without any change requirements of the production code. Maybe im mistaken but the count_n_players should already be implemented. I guess what you mean is that the call signature if create app has to be modified here.  i would suggest rethinking this section. It seem lazy when you say I will not repeat myself here but maybe im missing something.</p> <p>I think the reviewer misunderstood that this chapter starts from scratch again. I've made this more clear in the chapter's text.</p> <p>2.4.5 An important concept when doing TDD is to write only enough production (non-test code) to pass the test. In this section I think you are writing more than needed to pass the test. Eg the test don\u2019t care about sprite or its transform yet in this section you are writing the code for it.</p> <p>I agree that at the same time the world get a player added, that player also is directly set at the correct location. This correct location 'hitchhiked' with adding the player. The reviewer is right that it should have been done in smaller steps. I've added this to the FAQ.</p> <p>However, maybe I can simplify the setup ...</p> <p>Having given it some thoughts, I actually enjoy to go from big to small, so I keep it.</p> <p>I see now that you add the test for transorm afterwards which is ok when you are experienced, but for a new TDDer you need to break thibgs down in really small steps:</p> <ul> <li>write a list of possible tests</li> <li>pick an easy test</li> <li>write a failing test</li> <li>write enough production code to make it pass</li> <li>clean up removing duplications/refactoring</li> </ul> <p>I believe your audience (new to tdd) would benefit of this breaking down of small steps.</p> <p>I agree that I should split up in more tests, will work on this now.</p> <p>Thanks for the feedback!</p>"},{"location":"introduction/introduction/","title":"1. Introduction","text":"<p>Welcome to this book! This book is called 'Developing Bevy games using TDD'. The goal of this book is to demonstrate how to do Test-Driven Development with Bevy.</p> <p>This introductory chapter describes the ideas behind this book. If you want to dive right in, go to the next chapter now!</p>"},{"location":"introduction/introduction/#11-why-this-book","title":"1.1. Why this book?","text":"<p>This book started from the question: 'Is Bevy suitable for Test-Driven Development?', as the author was looking for a Rust gaming library suitable for Test-Driven Development.</p> <p>At the time of writing, there is only one blog post on Test-Driven Development with Bevy, which only has two tests. And that test suite has not been built up from scratch.</p> <p>This book starts from scratch and builds up gradually.</p> <p>This book started from the question: 'Is Bevy suitable for Test-Driven Development?'. To answer this question, this book aims for 100% code coverage in all code whenever possible and reasonable. When 100% code coverage in such code is achieved, the question is -to me- answered with a 'yes'.</p>"},{"location":"introduction/introduction/#12-what-is-the-intended-audience-of-this-book","title":"1.2. What is the intended audience of this book?","text":"<p>This book is suitable for intermediate Rust developers: people that have read parts of 'The Rust programming language' <code>[Klabnik &amp; Nichols, 2018][Klabnik &amp; Nichols, 2023]</code> and are able to write functions and structures.</p> <p>This book does not teach Rust, nor Bevy. Instead, it shows Test-Driven Development in Rust with Bevy.</p>"},{"location":"introduction/introduction/#13-what-is-the-goal-of-this-book","title":"1.3. What is the goal of this book?","text":"<p>The goal is to demonstrate how to do Test-Driven Development in Rust with Bevy.</p> <p>Each chapter introduces as much new concepts as needed, which is as few as possible. Due to this, the first chapters do not result in a playable game yet.</p>"},{"location":"introduction/introduction/#14-how-to-read-this-book","title":"1.4. How to read this book?","text":"<p>Start at chapter 1 and then move forwards chronologically, as the book introduces concepts one at a time. However, using this book as a reference for code snippets will probably work out fine too.</p>"},{"location":"introduction/introduction/#15-references","title":"1.5. References","text":"<ul> <li><code>[Klabnik &amp; Nichols, 2018]</code> Klabnik, Steve, and Carol Nichols.   The Rust programming language. No Starch Press, 2018.</li> <li><code>[Klabnik &amp; Nichols, 2023]</code> Klabnik, Steve, and Carol Nichols.   The Rust programming language. No Starch Press, 2023.</li> </ul>"},{"location":"misc/basic_introduction/","title":"2.1. Introduction","text":"<p>In this section, we start building simple Bevy programs, using test-driven development and gradually introducing Bevy terminology.</p> <p>Here you can see the recommended reading order of chapters:</p> <pre><code>flowchart TD\n  introduction[2.1.Introduction: This chapter]\n  hello_world[2.2.hello_world: Get started]\n  add_player[2.3.add_player: Add a player]\n  add_player_sprite[2.4.add_player_sprite: Add a player sprite]\n  add_player_sprite_with_texture[2.5.add_player_sprite_with_texture: Add a player sprite with a texture]\n  add_camera[2.6.add_camera: Add a camara]\n  move_player[2.7.move_player: Move the player]\n  add_text[2.8.add_text: Add text]\n  move_camera[move_camera: Move the camera]\n\n  introduction --&gt; hello_world\n  hello_world --&gt; add_player\n  add_player --&gt; add_player_sprite\n  add_player_sprite --&gt; add_player_sprite_with_texture\n  add_player_sprite_with_texture --&gt; add_text\n  add_player_sprite_with_texture --&gt; add_camera\n  add_player_sprite --&gt; move_player\n  move_player -.-&gt; |optional| move_camera</code></pre> <p>The last chapter <code>move_camera</code> is an optional chapter and part of the appendix, as it introduces no new concepts.</p>"},{"location":"misc/contributors/","title":"Acknowledgements and contributors","text":"<p>These are people and websites that helped me, in alphabetical order:</p> <ul> <li>https://github.com/aldeka/rustacean.net for providing ferris.png and ferris.svg</li> <li>Edgardo Carreras for his feedback on an early draft</li> <li><code>faervan</code>: answered a question on the Bevy Discord channel</li> <li>Hukasu: answered a question on the Bevy Discord channel</li> <li><code>inodentry</code> for starting the Unofficial Bevy Cheat Book, as well as its contributors</li> <li><code>kristoff3r</code>: answered a question on the Bevy Discord channel</li> <li><code>mgi388</code>: answered a question on the Bevy Discord channel</li> <li><code>Periwinkle</code>: answered a question on the Bevy Discord channel</li> <li><code>s33n</code>: answered a question on the Bevy Discord channel</li> <li><code>Shane Celis</code>: helped answer multiple questions on the Bevy Discord channel</li> <li>https://github.com/TheoPannetier for pointing out I should update my mermaid markup</li> <li><code>Trent (SleepyTea)</code>: helped answer some questions on the Bevy Discord channel</li> <li><code>Ziven</code>: helped answer a question on the Bevy Discord channel</li> </ul>"},{"location":"misc/definitions/","title":"Definitions","text":"<p>These definitions assume you know Rust.</p> <p>Please help me improve these definitions, especially with references to the literature.</p> Term Definition Bundle A collection of Components Commands A structure for doing something with a Bevy world Component A structure definition of something that can be added to a Bevy world Entity An instance of a Component System Something (typically a function) that works on a Bevy world World A collection of Entities and Systems"},{"location":"misc/example_programs_introduction/","title":"Example programs","text":"<p>This section only shows (more) complete example programs.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>This section has no recommended order of reading yet.</p> <pre><code>flowchart TD\n  move_player_keyboard[move_player_keyboard: Move the player using keyboard]\n  move_camera_keyboard[move_camera_keyboard: Move the camer nusing keyboard]\n  move_player_mouse[move_player_mouse: Move the player using mouse]\n  move_camera_mouse[move_camera_mouse: Move the camera using mouse]\n  show_2d_coordinate_systems[show_2d_coordinate_systems: Show 2D coordinate: systems]</code></pre>"},{"location":"misc/faq/","title":"FAQ","text":""},{"location":"misc/faq/#book","title":"Book","text":""},{"location":"misc/faq/#why-this-book","title":"Why this book?","text":"<p>This book started from the question: 'Is Bevy suitable for Test-Driven Development?', as the author was looking for a Rust gaming library suitable for Test-Driven Development.</p> <p>At the time of writing, there is only one blog post on Test-Driven Development with Bevy, which only has two tests. And that test suite has not been built up from scratch.</p> <p>This book tries to start from scratch and build up gradually, always aiming for 100% code coverage.</p> <p>When all facets of a game can be tested with 100% code coverage, the question 'Is Bevy suitable for Test-Driven Development?' can be answered with a 'yes'.</p>"},{"location":"misc/faq/#what-is-the-intended-audience-of-this-book","title":"What is the intended audience of this book?","text":"<p>Intermediate Rust developers: people that have read parts of 'The Rust programming language' <code>[Klabnik &amp; Nichols, 2018]``[Klabnik &amp; Nichols, 2023]</code>.</p> <p>This book does not teach Rust, nor Bevy. Instead, it shows Test-Driven Development in Rust with Bevy.</p>"},{"location":"misc/faq/#what-is-the-goal-of-this-book","title":"What is the goal of this book?","text":"<p>The goal is to demonstrate how to do Test-Driven Development in Rust with Bevy.</p> <p>Each chapter introduces as much new concepts as needs, which is as few as possible. Due to this, the first chapters do not result in a playable game yet.</p>"},{"location":"misc/faq/#what-are-the-subgoals-of-this-book","title":"What are the subgoals of this book?","text":"<ul> <li>Code is tested to work; it can be detected when the code is not working   anymore.</li> <li>Always achieve 100% code coverage when ignoring   the <code>main</code> function in <code>src/main.rs</code></li> <li>Follow the Rust idiom as suggested by the <code>clippy</code> Rust package</li> <li>Get the test to work as simply as possible<ul> <li>No marker <code>Components</code> when tests pass without using these</li> </ul> </li> <li>The first chapters must be simple enough to reasonably be put in one single file</li> <li>Only call Bevy with <code>use bevy::prelude::*;</code>, use full names beyond that (e.g.   <code>bevy::input::InputPlugin</code>) over adding more <code>use</code>s</li> <li>Have a running program in each chapter</li> </ul>"},{"location":"misc/faq/#what-are-the-non-goals-of-this-book","title":"What are the non-goals of this book?","text":"<ul> <li>Having an interesting game in the end</li> <li>Always have the fastest solution</li> <li>The TDD tests are as small as possible, in the most natural sequence</li> </ul> Why is this a non-goal? <p>It is more important that all code is tested to work. There is a script called <code>check_chapters</code> that checks if all lines of code in the book are indeed taken from the lines of code of each chapter's full code.</p> <p>Due to this, it is impossible to discuss all in-between steps.</p> <p>For example, imagine this function signature, needed at the end of the chapter:</p> <pre><code>// Create a Bevy App, with a player at 'position' and size 'size'\nfn create_app(position: Vec2, size: Vec2) -&gt; App {\n    // ...\n}\n</code></pre> <p>In regular TDD, one would build up <code>create_app</code> to first have no argument and add the arguments one at a time instead. This would also mean that tests using <code>create_app</code> would change. And that older versions of these tests cannot be put in the book's chapters: that code would be untested...</p> <p>... where it is more important that all code is tested to work.</p> <ul> <li>Explain Rust</li> <li>Explain Bevy deeper than the examples require. For example,   in chapter <code>add_player</code> a simple definition of an <code>Entity</code> is given:   'an instance of <code>Component</code>'. This definition purposefully ignores that   an <code>Entity</code> also has a unique identifier, as it is not help to better   understand the code of that chapter</li> <li>Support code of older Bevy version</li> <li>Give tips that are of personal preference,   unless described as such</li> <li>Use fancy idioms that are of personal preference,   unless described as such</li> </ul>"},{"location":"misc/faq/#are-there-other-sources-you-recommend","title":"Are there other sources you recommend?","text":"<ul> <li>The Bevy examples:   these are the official examples supported by Bevy.   The difference with this book is that some of these examples   show multiple things and does not have tests.   Compare, for example,   the Bevy Text2d example   with this books 'Add text' chapter   seem to be more focused on being pretty, over being focused.</li> <li>The Unofficial Bevy Cheat Book:   these are code snippets alongside explanations.   The difference with this book is that these snippets   are not stand-alone and do not have tests.</li> <li>The unofficial 'Learn Bevy Book'</li> </ul>"},{"location":"misc/faq/#general","title":"General","text":""},{"location":"misc/faq/#why-use-test-driven-development","title":"Why use Test-Driven Development?","text":"<p>TDD is known to improve code quality <code>[Alkaoud &amp; Walcott, 2018][Janzen &amp; Saiedian, 2006]</code>.</p>"},{"location":"misc/faq/#why-is-100-code-coverage-important","title":"Why is 100% code coverage important?","text":"<p>Code coverage correlates with code quality <code>[Horgan et al., 1994]</code> <code>[Del Frate et al., 1995]</code>. Due to this, having a code coverage of (around) 100% is mandatory to pass a code peer-review by committees such as, for example, rOpenSci <code>[Ram, 2013]</code>.</p>"},{"location":"misc/faq/#why-is-continuous-integration-testing-important","title":"Why is Continuous Integration testing important?","text":"<p>Software inherently degrades (for example, due to changes in the Bevy library) and we should take that as a given [Beck, 2000]. Continuous Integration is known to significantly increase the number of bugs exposed and increases the speed at which new features are added <code>[Vasilescu et al., 2015]</code>.</p> <p>In the context of this book, a bug can be:</p> <ul> <li>the code shown in the chapters does not match the tested code   of the repository these are copy-pasted from anymore</li> <li>spelling errors</li> <li>markdown style errors</li> <li>broken links</li> </ul>"},{"location":"misc/faq/#why-is-using-a-rust-linter-important","title":"Why is using a Rust linter important?","text":"<p>Following a consistent coding style improves software quality <code>[Fang, 2001]</code>.</p>"},{"location":"misc/faq/#technical","title":"Technical","text":""},{"location":"misc/faq/#how-is-code-tested-to-work","title":"How is code tested to work?","text":"<p>The CI script 'Check chapters' checks if each line in the chapters can be found in the complete projects there were copy-pasted from. In that way, if code changes in the projects, the chapters must be updated for the CI scripts to pass.</p>"},{"location":"misc/faq/#why-ignore-the-main-function-in-srcmainrs-for-code-coverage","title":"Why ignore the <code>main</code> function in <code>src/main.rs</code> for code coverage?","text":"<p>Because one cannot test the <code>main</code> function.</p> <p>The <code>main</code> is where a game is started. When the game is started, one needs user input to close the game. TDD needs tests that do not require user input.</p>"},{"location":"misc/faq/#why-dont-you-use-dynamic-linking","title":"Why don't you use dynamic linking?","text":"<p>The Bevy setup recommends to use dynamic linking, as this results in faster build times.</p> <p>However, when using dynamic linking, I was unable to use the debugger in neither Visual Studio Code, nor RustRover.</p> <p>As I prefer using a debugger over fast build times, I choose to not use dynamic linking and -indeed- wait a bit longer for a build to finish.</p> <p>If you want to use dynamic linking, to a <code>Cargo.toml</code> file, change:</p> <pre><code>[dependencies]\nbevy = { version = \"0.14.0\" }\n</code></pre> <p>to</p> <pre><code>[dependencies]\nbevy = { version = \"0.14.0\", features = [\"dynamic_linking\"] }\n</code></pre>"},{"location":"misc/faq/#about-the-author","title":"About the author","text":""},{"location":"misc/faq/#which-rust-ide-do-you-like-best","title":"Which Rust IDE do you like best?","text":"<p>These are the IDEs I tried:</p> <ul> <li>RustRover</li> <li>Visual Studio Code</li> </ul> <p>My favorite is RustRover. RustRover is specialized in Rust development, where Visual Studio Code is a general-purpose IDE, and this is noticeable to me:</p> <ul> <li>RustRover works better out-of-of-the-box under my operating system (Linux, with Ubuntu 22.04 LTS and Ubuntu 24.04 LTS)</li> <li>RustRover does not take all CPUs when building, so I can work on lightweight other things too</li> <li>RustRover has the keyboard shortcuts setup for the things I need, with combinations that feel natural to me</li> </ul>"},{"location":"misc/faq/#my-open-questions","title":"My open questions","text":""},{"location":"misc/faq/#use-setup_-or-add_-for-functions-that-add-components-in-the-setup-phase","title":"Use <code>setup_</code> or <code>add_</code> for functions that add components in the Setup phase?","text":"<p>The Bevy example often start functions that add <code>Components</code> at the <code>App</code> at startup with <code>setup</code>, e.g. <code>setup_camera</code>. As the functions add things, I use the verb <code>add</code> instead, e.g. <code>add_camera</code>. Should I follow the -IMHO- better English description of what the function does (i.e. use <code>add</code>), or should I follow the Bevy social convention to use <code>setup</code>?</p>"},{"location":"misc/faq/#is-there-a-way-to-do-a-query-on-a-immutable-world","title":"Is there a way to do a Query on a immutable World?","text":"<p>This is a test I would like to be able to write:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let app = App::new();\n    assert_eq!(count_n_players(&amp;app), 0);\n}\n</code></pre> <p>The idea of <code>count_n_players</code> is to count the number of times a (marker) component is present. Because we only read (i.e. do not modify the <code>App</code>), we can write <code>let app</code> (instead of <code>let mut app</code>).</p> <p>Writing this test, however, fails when implementing <code>count_n_players</code>.</p> <p>Below is an implementation that I wish I could write, that uses a query on an immutable <code>World</code>:</p> <pre><code>// Does not compile, as `query` expects a mutable World\nfn count_n_players(app: &amp;App) -&gt; usize {\n    let query = app.world().query::&lt;&amp;Player&gt;();\n    return query.iter(app.world()).len();\n}\n</code></pre> <p>However, a query always needs a mutable World, hence an implementation that works is:</p> <pre><code>// Does not modify the App, I promise!\nfn count_n_players(app: &amp;mut App) -&gt; usize {\n    let mut query = app.world_mut().query::&lt;&amp;Player&gt;();\n    return query.iter(app.world()).len();\n}\n</code></pre> <p>I added a comment to illustrate that one needs to promise not to change an object, instead of enforcing it (i.e. not using <code>mut</code>).</p> <p>With an implementation that uses <code>&amp;mut App</code>, the test needs to be changed to:</p> <pre><code>fn test_empty_app_has_no_players() {\n    let mut app = App::new();\n    // Does not modify the App, I promise!\n    assert_eq!(count_n_players(&amp;mut app), 0);\n}\n</code></pre> <p>Also here I added a comment to illustrate that one needs to promise not to change an object, instead of enforcing it (i.e. not using <code>mut</code>).</p> <p>I assume that also in Bevy I express my promises in Rust, so how do I query something on an immutable <code>App</code>?</p>"},{"location":"misc/faq/#references","title":"References","text":"<ul> <li><code>[Alkaoud &amp; Walcott, 2018]</code> Alkaoud, Hessah, and Kristen R. Walcott. \"Quality metrics of test suites in test-driven designed applications.\" International Journal of Software Engineering Applications (IJSEA) 2018 (2018).</li> <li><code>[Beck, 2000]</code> Beck, Kent. Extreme programming explained: embrace change. addison-wesley professional, 2000.</li> <li><code>[Del Frate et al., 1995]</code> Del Frate, Fabio, et al. \"On the correlation between code coverage and software reliability.\" Proceedings of Sixth International Symposium on Software Reliability Engineering. ISSRE'95. IEEE, 1995.</li> <li><code>[Fang, 2001]</code> Fang, Xuefen. \"Using a coding standard to improve program quality.\" Proceedings Second Asia-Pacific Conference on Quality Software. IEEE, 2001.</li> <li><code>[Horgan et al., 1994]</code> Horgan, Joseph R., Saul London, and Michael R. Lyu. \"Achieving software quality with testing coverage measures.\" Computer 27.9 (1994): 60-69.</li> <li><code>[Janzen &amp; Saiedian, 2006]</code> Janzen, David S., and Hossein Saiedian. \"Test-driven learning: intrinsic integration of testing into the CS/SE curriculum.\" Acm Sigcse Bulletin 38.1 (2006): 254-258.</li> <li><code>[Klabnik &amp; Nichols, 2018]</code> Klabnik, Steve, and Carol Nichols.   The Rust programming language. No Starch Press, 2023.</li> <li><code>[Klabnik &amp; Nichols, 2023]</code> Klabnik, Steve, and Carol Nichols.   The Rust programming language. No Starch Press, 2023.</li> <li><code>[Ram, 2013]</code> Ram, K. \"rOpenSci-open tools for open science.\" AGU Fall Meeting Abstracts. Vol. 2013. 2013.</li> <li><code>[Vasilescu et al., 2015]</code> Vasilescu, Bogdan, et al. \"Quality and productivity outcomes relating to continuous integration in GitHub.\" Proceedings of the 2015 10th joint meeting on foundations of software engineering. 2015.</li> </ul>"},{"location":"misc/functions/","title":"Functions","text":"<p>This appendix contains functions that are useful in testing.</p> <ul> <li>get_all_components_names</li> <li>print_all_components_names</li> </ul>"},{"location":"misc/functions/#get_all_components_names","title":"get_all_components_names","text":"<pre><code>fn get_all_components_names(app: &amp;App) -&gt; Vec&lt;String&gt; {\n    use std::str::FromStr;\n\n    let mut v: Vec&lt;String&gt; = Vec::new();\n    for c in app.world().components().iter() {\n        v.push(String::from_str(c.name()).unwrap());\n    }\n    return v;\n}\n</code></pre>"},{"location":"misc/functions/#print_all_components_names","title":"print_all_components_names","text":"<pre><code>fn print_all_components_names(app: &amp;App) {\n    for c in app.world().components().iter() {\n        println!(\"{}\", c.name())\n    }\n}\n</code></pre>"},{"location":"misc/misc_introduction/","title":"Misc","text":"<p>This section only shows miscellaneous things that do not fit in the current book structure.</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p>"},{"location":"misc/respond_to_input_introduction/","title":"Section 3: Respond to input","text":"<p>In this section, we start building simple Bevy programs that respond to user input.</p> <p>Not ready for yet</p> <p>This section remains unfinished until feedback about the previous sections has been received.</p> <p>This section has no recommended order of reading yet.</p> <pre><code>flowchart TD\n  respond_to_key_press[respond_to_key_press: Respond to a key press]\n  respond_to_mouse_move[respond_to_mouse_move: Respond to a mouse move]\n  respond_to_mouse_button_press[respond_to_mouse_button_press: Respond to a mouse button press]\n  respond_to_mouse_wheel_press[respond_to_mouse_wheel_press: Respond to a mouse wheel press]\n  respond_to_mouse_wheel_turn[respond_to_mouse_wheel_turn: Respond to a mouse wheel turn]\n  respond_to_just_key_pressed[respond_to_just_key_pressed: Respond to a key that has just been pressed]\n  respond_to_window_resize[respond_to_window_resize: Respond to a window that resizes]</code></pre>"},{"location":"misc/status/","title":"Status","text":"<p>Here I keep an overview of the status of the chapters.</p>"},{"location":"misc/status/#section-1-introduction","title":"Section 1: introduction","text":"<ul> <li>1.1. Introduction</li> </ul>"},{"location":"misc/status/#section-2-basics","title":"Section 2: basics","text":"<ul> <li>2.1. Introduction</li> </ul> Code Build status Code coverage Chapter code hello_world.md code add_player.md code add_player_sprite.md code add_player_sprite_with_texture.md code add_text.md code add_camera.md code move_player.md"},{"location":"misc/status/#section-3-user-input","title":"Section 3: user input","text":"<ul> <li>3.1. Introduction</li> </ul> Code Build status Code coverage Chapter code respond_to_window_resize.md code respond_to_key_press.md code respond_to_just_key_pressed.md code respond_to_mouse_move.md code respond_to_mouse_button_press.md code respond_to_mouse_wheel_turn.md code respond_to_mouse_wheel_press.md <ul> <li>gamepad</li> </ul>"},{"location":"misc/status/#section-4-media","title":"Section 4: media","text":"<ul> <li>Adding a 3D player with a texture</li> <li>3D models</li> <li>drawing</li> <li>animations</li> <li>sounds</li> <li>other suggestions from feedback</li> </ul>"},{"location":"misc/status/#section-99-graphical-user-interface-testing","title":"Section 99: Graphical user interface testing","text":"<ul> <li>Testing for a key press to close the game</li> </ul>"},{"location":"misc/status/#section-for-possible-chapters","title":"Section for possible chapters","text":"Code Build status Code coverage Chapter code use_game_state.md code use_resources.md code use_window_title.md code click_sprite.md"},{"location":"misc/status/#appendix","title":"Appendix","text":"Code Build status Code coverage Chapter code move_camera.md code move_camera_with_keyboard.md code move_player_with_keyboard.md code move_camera_with_mouse.md code move_player_with_mouse.md code show_2d_coordinate_systems.md"}]}